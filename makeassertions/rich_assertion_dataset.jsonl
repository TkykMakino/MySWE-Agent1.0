{"title": "辞書から値を安全に取得する関数", "description": "この例では、辞書から値を安全に取得する関数に対して、辞書の型チェック、キーの存在チェック、デフォルト値の扱いに関するアサーションとデバッグプリントを追加しています。辞書操作を行う関数でよく見られるパターンで、引数の型チェックやキーの存在確認を厳密に行いたい場合に有効です。", "keywords": ["dict", "get", "isinstance", "KeyError", "default", "type checking"], "code_before": "def get_from_dict(data, key, default=None):\n    if key in data:\n        return data[key]\n    return default", "code_after": "def get_from_dict(data, key, default=None):\n    print(f\"[DEBUG] get_from_dict called with data={data}, key={key}, default={default}\")\n    \n    # Type assertions\n    assert isinstance(data, dict), f\"Expected dictionary, got {type(data).__name__}\"\n    assert isinstance(key, (str, int, float, bool, tuple)), f\"Key must be a hashable type, got {type(key).__name__}\"\n    \n    print(f\"[DEBUG] Checking if {key} exists in dictionary\")\n    if key in data:\n        value = data[key]\n        print(f\"[DEBUG] Key {key} found, returning value: {value}\")\n        return value\n    \n    print(f\"[DEBUG] Key {key} not found, returning default: {default}\")\n    return default", "test_cases": {"success": [{"input": ["{'name': 'John', 'age': 30}", "'name'", "None"], "expected_output": "'John'"}, {"input": ["{'name': 'John', 'age': 30}", "'email'", "'unknown'"], "expected_output": "'unknown'"}, {"input": ["{}", "123", "None"], "expected_output": "None"}], "failure": [{"input": ["'not a dict'", "'key'"], "expected_exception": "AssertionError", "expected_message_part": "Expected dictionary, got str"}, {"input": ["{'name': 'John'}", "[1, 2, 3]"], "expected_exception": "AssertionError", "expected_message_part": "Key must be a hashable type, got list"}]}}
{"title": "リストの要素を合計する関数", "description": "数値リストの合計を計算する関数において、入力チェックと計算過程の可視化のためのアサーションとデバッグプリントを追加しています。リスト操作と数値計算を行う関数で、入力値の検証と処理の追跡が重要な場合に有効です。特に、リストの各要素が数値であることを保証し、計算過程を明示的に表示します。", "keywords": ["list", "sum", "isinstance", "iteration", "accumulator", "type checking"], "code_before": "def sum_numbers(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total", "code_after": "def sum_numbers(numbers):\n    print(f\"[DEBUG] sum_numbers called with numbers={numbers}\")\n    \n    # Type assertions\n    assert isinstance(numbers, (list, tuple)), f\"Expected list or tuple, got {type(numbers).__name__}\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"All elements must be numbers\"\n    \n    total = 0\n    print(f\"[DEBUG] Starting calculation with initial total = {total}\")\n    \n    for i, num in enumerate(numbers):\n        assert num >= 0, f\"Negative number found at index {i}: {num}\"\n        prev_total = total\n        total += num\n        print(f\"[DEBUG] Adding {num} to {prev_total}, new total = {total}\")\n    \n    print(f\"[DEBUG] Calculation complete. Final total = {total}\")\n    return total", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "15"}, {"input": ["[0, 0, 0]"], "expected_output": "0"}, {"input": ["[1.5, 2.5, 3.0]"], "expected_output": "7.0"}], "failure": [{"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "Expected list or tuple, got str"}, {"input": ["[1, 2, 'three', 4]"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}, {"input": ["[1, 2, -3, 4]"], "expected_exception": "AssertionError", "expected_message_part": "Negative number found at index 2: -3"}]}}
{"title": "文字列の単語数をカウントする関数", "description": "文字列内の単語数をカウントする関数に対して、入力検証と処理プロセスの可視化を行うアサーションとデバッグプリントを追加しています。テキスト処理関数において、入力文字列の検証、分割処理の確認、結果の検証を行う典型的なパターンです。", "keywords": ["string", "split", "count", "len", "str", "text processing"], "code_before": "def count_words(text):\n    words = text.split()\n    return len(words)", "code_after": "def count_words(text):\n    print(f\"[DEBUG] count_words called with text='{text}'\")\n    \n    # Type and value assertions\n    assert isinstance(text, str), f\"Expected string input, got {type(text).__name__}\"\n    assert len(text.strip()) > 0, \"Input string cannot be empty or only whitespace\"\n    \n    print(f\"[DEBUG] Splitting text into words\")\n    words = text.split()\n    \n    print(f\"[DEBUG] Found {len(words)} words: {words}\")\n    \n    # Validate results\n    for i, word in enumerate(words):\n        print(f\"[DEBUG] Word {i+1}: '{word}'\")\n        assert len(word) > 0, f\"Empty word found at position {i}\"\n    \n    word_count = len(words)\n    print(f\"[DEBUG] Final word count: {word_count}\")\n    return word_count", "test_cases": {"success": [{"input": ["'Hello world'"], "expected_output": "2"}, {"input": ["'The quick brown fox jumps over the lazy dog'"], "expected_output": "9"}, {"input": ["'One'"], "expected_output": "1"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Expected string input, got int"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "Input string cannot be empty or only whitespace"}, {"input": ["'   '"], "expected_exception": "AssertionError", "expected_message_part": "Input string cannot be empty or only whitespace"}]}}
{"title": "範囲内の素数を生成する関数", "description": "指定された範囲内の素数を生成する関数に対して、入力パラメータの検証とアルゴリズムの実行過程を追跡するためのアサーションとデバッグプリントを追加しています。数値アルゴリズムの実装において、入力範囲の検証と処理の各ステップを可視化することで、関数の正確性と実行効率の確認が容易になります。", "keywords": ["prime", "range", "algorithm", "generator", "math", "bounds checking"], "code_before": "def generate_primes(start, end):\n    primes = []\n    for num in range(start, end + 1):\n        if num > 1:\n            is_prime = True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                primes.append(num)\n    return primes", "code_after": "def generate_primes(start, end):\n    print(f\"[DEBUG] generate_primes called with start={start}, end={end}\")\n    \n    # Input validation\n    assert isinstance(start, int), f\"Start must be an integer, got {type(start).__name__}\"\n    assert isinstance(end, int), f\"End must be an integer, got {type(end).__name__}\"\n    assert start >= 0, f\"Start must be non-negative, got {start}\"\n    assert end >= start, f\"End ({end}) must be greater than or equal to start ({start})\"\n    assert end - start <= 10000, f\"Range too large: {end - start + 1} numbers\"\n    \n    primes = []\n    print(f\"[DEBUG] Searching for primes in range [{start}, {end}]\")\n    \n    for num in range(start, end + 1):\n        print(f\"[DEBUG] Checking if {num} is prime\")\n        if num > 1:\n            is_prime = True\n            sqrt_num = int(num ** 0.5) + 1\n            print(f\"[DEBUG] Testing divisibility up to {sqrt_num}\")\n            \n            for i in range(2, sqrt_num):\n                if num % i == 0:\n                    print(f\"[DEBUG] {num} is divisible by {i}, not prime\")\n                    is_prime = False\n                    break\n            \n            if is_prime:\n                print(f\"[DEBUG] {num} is prime, adding to list\")\n                primes.append(num)\n        else:\n            print(f\"[DEBUG] {num} <= 1, not prime\")\n    \n    print(f\"[DEBUG] Found {len(primes)} primes: {primes}\")\n    return primes", "test_cases": {"success": [{"input": ["2", "10"], "expected_output": "[2, 3, 5, 7]"}, {"input": ["20", "30"], "expected_output": "[23, 29]"}, {"input": ["0", "5"], "expected_output": "[2, 3, 5]"}], "failure": [{"input": ["'2'", "10"], "expected_exception": "AssertionError", "expected_message_part": "Start must be an integer, got str"}, {"input": ["10", "5"], "expected_exception": "AssertionError", "expected_message_part": "End (5) must be greater than or equal to start (10)"}, {"input": ["-5", "10"], "expected_exception": "AssertionError", "expected_message_part": "Start must be non-negative, got -5"}, {"input": ["1", "20000"], "expected_exception": "AssertionError", "expected_message_part": "Range too large: 20000 numbers"}]}}
{"title": "二分探索アルゴリズムの実装", "description": "二分探索の実装において、入力配列のソート状態の検証、中間処理の進捗状況の確認、処理の開始・終了ログが重要です。このパターンはリストが事前にソートされていることを前提とする関数に適しており、アサーションで境界条件を厳密にチェックします。", "keywords": ["binary search", "sorted list", "algorithm", "log n", "recursion"], "code_before": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "code_after": "def binary_search(arr, target):\n    # アサーション: 入力が有効な配列かチェック\n    assert isinstance(arr, list), \"配列はリスト型である必要があります\"\n    \n    # アサーション: 対象が存在する（空でない）\n    assert len(arr) > 0, \"空の配列に対して二分探索はできません\"\n    \n    # アサーション: 配列がソートされているかチェック\n    assert all(arr[i] <= arr[i+1] for i in range(len(arr)-1)), \"二分探索には昇順ソート済み配列が必要です\"\n    \n    print(f\"[DEBUG] 二分探索開始: 配列長={len(arr)}, 探索対象={target}\")\n    \n    left, right = 0, len(arr) - 1\n    iteration = 0\n    \n    while left <= right:\n        iteration += 1\n        mid = (left + right) // 2\n        print(f\"[DEBUG] 反復#{iteration}: left={left}, right={right}, mid={mid}, mid_value={arr[mid]}\")\n        \n        if arr[mid] == target:\n            print(f\"[DEBUG] ターゲット{target}が位置{mid}で見つかりました\")\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n            print(f\"[DEBUG] ターゲットは右側にあります。新しいleft={left}\")\n        else:\n            right = mid - 1\n            print(f\"[DEBUG] ターゲットは左側にあります。新しいright={right}\")\n    \n    print(f\"[DEBUG] ターゲット{target}が見つかりませんでした\")\n    return -1", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "7"], "expected_output": "6"}, {"input": ["[1, 3, 5, 7, 9]", "5"], "expected_output": "2"}, {"input": ["[1, 3, 5, 7, 9]", "10"], "expected_output": "-1"}], "failure": [{"input": ["[]", "5"], "expected_exception": "AssertionError", "expected_message_part": "空の配列に対して二分探索はできません"}, {"input": ["[9, 5, 3, 1]", "3"], "expected_exception": "AssertionError", "expected_message_part": "二分探索には昇順ソート済み配列が必要です"}, {"input": ["'not a list'", "5"], "expected_exception": "AssertionError", "expected_message_part": "配列はリスト型である必要があります"}]}}
{"title": "電子メールアドレスの検証関数", "description": "電子メールアドレスの検証のような入力検証関数では、入力の型と内容を厳密に検証することが重要です。このパターンは正規表現を使用した文字列バリデーションに適しており、入力の詳細な特性について複数のアサーションを使って段階的に検証します。", "keywords": ["regex", "validation", "email", "string", "pattern matching"], "code_before": "import re\n\ndef validate_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))", "code_after": "import re\n\ndef validate_email(email):\n    # 関数開始のデバッグプリント\n    print(f\"[DEBUG] validate_email 関数開始: email={email}\")\n    \n    # 入力タイプのアサーション\n    assert email is not None, \"メールアドレスがNoneです\"\n    assert isinstance(email, str), \"メールアドレスは文字列である必要があります\"\n    \n    # 基本的な長さのアサーション\n    assert len(email) > 0, \"メールアドレスが空です\"\n    assert len(email) <= 320, \"メールアドレスが長すぎます（最大320文字）\"\n    \n    # @記号の存在チェック\n    assert '@' in email, \"メールアドレスには@記号が必要です\"\n    \n    # ユーザー名とドメイン部分に分割\n    parts = email.split('@')\n    assert len(parts) == 2, \"メールアドレスに@記号は1つだけ必要です\"\n    \n    username, domain = parts\n    print(f\"[DEBUG] ユーザー名部分: {username}, ドメイン部分: {domain}\")\n    \n    # ユーザー名とドメインの長さチェック\n    assert len(username) > 0, \"ユーザー名部分が空です\"\n    assert len(domain) > 0, \"ドメイン部分が空です\"\n    \n    # ドメインにはドットが必要\n    assert '.' in domain, \"ドメイン部分にはドットが必要です\"\n    \n    # 正規表現パターン\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    result = bool(re.match(pattern, email))\n    \n    print(f\"[DEBUG] 正規表現チェック結果: {result}\")\n    print(f\"[DEBUG] validate_email 関数終了: 結果={result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["'user@example.com'"], "expected_output": "True"}, {"input": ["'user.name+tag@example-site.co.uk'"], "expected_output": "True"}, {"input": ["'invalid.email@'"], "expected_output": "False"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスがNoneです"}, {"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスは文字列である必要があります"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスが空です"}, {"input": ["'a' * 321"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスが長すぎます"}, {"input": ["'invalidemail'"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスには@記号が必要です"}, {"input": ["'user@domain@example.com'"], "expected_exception": "AssertionError", "expected_message_part": "メールアドレスに@記号は1つだけ必要です"}, {"input": ["'@domain.com'"], "expected_exception": "AssertionError", "expected_message_part": "ユーザー名部分が空です"}, {"input": ["'user@'"], "expected_exception": "AssertionError", "expected_message_part": "ドメイン部分が空です"}, {"input": ["'user@domainwithoutdot'"], "expected_exception": "AssertionError", "expected_message_part": "ドメイン部分にはドットが必要です"}]}}
{"title": "パスワード強度チェック関数", "description": "このパターンは複数の条件チェックを含む関数において有効です。アサーションにより入力値の型を検証し、各チェック条件の前後でデバッグプリントを挿入することで、条件判定のフローを追跡できます。各チェック項目（長さ、大文字、小文字、数字、特殊文字）ごとにデバッグ出力を行い、どの条件で失敗したのかを即座に特定できます。", "keywords": ["password", "validation", "string", "regex", "security", "if", "re.search"], "code_before": "import re\n\ndef check_password_strength(password):\n    score = 0\n    \n    # Check length\n    if len(password) >= 8:\n        score += 1\n    \n    # Check for uppercase\n    if re.search(r'[A-Z]', password):\n        score += 1\n    \n    # Check for lowercase\n    if re.search(r'[a-z]', password):\n        score += 1\n    \n    # Check for digits\n    if re.search(r'\\d', password):\n        score += 1\n    \n    # Check for special characters\n    if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        score += 1\n    \n    return score", "code_after": "import re\n\ndef check_password_strength(password):\n    print(f\"Starting password strength check for: {password[:2]}{'*' * (len(password) - 2) if len(password) > 2 else ''}\")\n    \n    # Validate input\n    assert isinstance(password, str), \"Password must be a string\"\n    assert password, \"Password cannot be empty\"\n    \n    score = 0\n    print(f\"Initial score: {score}\")\n    \n    # Check length\n    length_check = len(password) >= 8\n    print(f\"Length check (>= 8): {length_check}, length = {len(password)}\")\n    if length_check:\n        score += 1\n        print(f\"Score after length check: {score}\")\n    \n    # Check for uppercase\n    has_uppercase = bool(re.search(r'[A-Z]', password))\n    print(f\"Uppercase check: {has_uppercase}\")\n    if has_uppercase:\n        score += 1\n        print(f\"Score after uppercase check: {score}\")\n    \n    # Check for lowercase\n    has_lowercase = bool(re.search(r'[a-z]', password))\n    print(f\"Lowercase check: {has_lowercase}\")\n    if has_lowercase:\n        score += 1\n        print(f\"Score after lowercase check: {score}\")\n    \n    # Check for digits\n    has_digit = bool(re.search(r'\\d', password))\n    print(f\"Digit check: {has_digit}\")\n    if has_digit:\n        score += 1\n        print(f\"Score after digit check: {score}\")\n    \n    # Check for special characters\n    has_special = bool(re.search(r'[!@#$%^&*(),.?\":{}|<>]', password))\n    print(f\"Special character check: {has_special}\")\n    if has_special:\n        score += 1\n        print(f\"Score after special character check: {score}\")\n    \n    print(f\"Final password strength score: {score} out of 5\")\n    return score", "test_cases": {"success": [{"input": ["'Password123!'"], "expected_output": "5"}, {"input": ["'short'"], "expected_output": "1"}, {"input": ["'ALLCAPS123!'"], "expected_output": "4"}], "failure": [{"input": [123], "expected_exception": "AssertionError", "expected_message_part": "Password must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "Password cannot be empty"}]}}
{"title": "ファイル拡張子に基づいたMIMEタイプ判定関数", "description": "この関数はファイル拡張子からMIMEタイプを判定します。アサーションを使って入力パラメータの型と値を検証し、デバッグプリントでファイルパスの解析過程と拡張子の抽出状況を追跡できるようにしています。特に、ファイルパスが実際に存在するかどうかのチェックや、サポートしていない拡張子の処理の流れが視覚化されており、エラー発生時のデバッグが容易になります。", "keywords": ["file", "extension", "MIME", "path", "os.path", "dictionary", "get", "lower"], "code_before": "import os\n\ndef get_mime_type(file_path):\n    # Dictionary mapping file extensions to MIME types\n    mime_types = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'application/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n        'pdf': 'application/pdf'\n    }\n    \n    # Get the file extension\n    _, ext = os.path.splitext(file_path)\n    ext = ext.lstrip('.').lower()\n    \n    # Return the MIME type if found, or a default type\n    return mime_types.get(ext, 'application/octet-stream')", "code_after": "import os\n\ndef get_mime_type(file_path):\n    print(f\"Starting MIME type determination for file: {file_path}\")\n    \n    # Validate input\n    assert isinstance(file_path, str), \"File path must be a string\"\n    assert file_path.strip(), \"File path cannot be empty\"\n    \n    # Dictionary mapping file extensions to MIME types\n    mime_types = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'application/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n        'pdf': 'application/pdf'\n    }\n    \n    print(f\"Supported extensions: {list(mime_types.keys())}\")\n    \n    # Check if file exists\n    file_exists = os.path.exists(file_path)\n    print(f\"File exists: {file_exists}\")\n    \n    # Get the file extension\n    filename, ext = os.path.splitext(file_path)\n    print(f\"Split result - Filename: {filename}, Extension: {ext}\")\n    \n    ext = ext.lstrip('.').lower()\n    print(f\"Normalized extension: '{ext}'\")\n    \n    # Check if extension is supported\n    is_supported = ext in mime_types\n    print(f\"Extension '{ext}' is supported: {is_supported}\")\n    \n    # Return the MIME type if found, or a default type\n    mime_type = mime_types.get(ext, 'application/octet-stream')\n    print(f\"Determined MIME type: {mime_type}\")\n    \n    return mime_type", "test_cases": {"success": [{"input": ["'document.txt'"], "expected_output": "'text/plain'"}, {"input": ["'image.JPG'"], "expected_output": "'image/jpeg'"}, {"input": ["'archive.zip'"], "expected_output": "'application/octet-stream'"}, {"input": ["'/path/to/file.pdf'"], "expected_output": "'application/pdf'"}], "failure": [{"input": [123], "expected_exception": "AssertionError", "expected_message_part": "File path must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "File path cannot be empty"}]}}
{"title": "日付文字列のフォーマット変換関数", "description": "日付文字列のフォーマットを変換する関数に対して、入力値の検証アサーションとデバッグプリントを追加しています。アサーションは入力文字列の型、空文字チェック、日付形式の妥当性を検証します。デバッグプリントでは、関数の処理開始、パースした日付の中間状態、出力フォーマット適用後の結果など、変換プロセスの各ステップを可視化しています。これにより、複雑な日付操作のデバッグが容易になります。", "keywords": ["date", "datetime", "strptime", "strftime", "format", "string", "conversion", "validation"], "code_before": "from datetime import datetime\n\ndef convert_date_format(date_string, input_format='%Y-%m-%d', output_format='%d/%m/%Y'):\n    # Parse the date string according to input format\n    date_obj = datetime.strptime(date_string, input_format)\n    \n    # Convert to the output format\n    formatted_date = date_obj.strftime(output_format)\n    \n    return formatted_date", "code_after": "from datetime import datetime\n\ndef convert_date_format(date_string, input_format='%Y-%m-%d', output_format='%d/%m/%Y'):\n    print(f\"Starting date format conversion for: '{date_string}'\")\n    print(f\"Input format: '{input_format}', Output format: '{output_format}'\")\n    \n    # Validate input parameters\n    assert isinstance(date_string, str), \"Date string must be a string\"\n    assert date_string.strip(), \"Date string cannot be empty\"\n    assert isinstance(input_format, str), \"Input format must be a string\"\n    assert isinstance(output_format, str), \"Output format must be a string\"\n    \n    try:\n        # Parse the date string according to input format\n        print(f\"Attempting to parse date string using format: {input_format}\")\n        date_obj = datetime.strptime(date_string, input_format)\n        print(f\"Successfully parsed date: {date_obj}\")\n        \n        # Convert to the output format\n        print(f\"Applying output format: {output_format}\")\n        formatted_date = date_obj.strftime(output_format)\n        print(f\"Formatted result: '{formatted_date}'\")\n        \n        return formatted_date\n    except ValueError as e:\n        print(f\"ERROR: Failed to parse date string: {e}\")\n        raise ValueError(f\"Invalid date string '{date_string}' for format '{input_format}': {e}\")", "test_cases": {"success": [{"input": ["'2023-01-15'", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_output": "'15/01/2023'"}, {"input": ["'01/15/2023'", "'%m/%d/%Y'", "'%Y-%m-%d'"], "expected_output": "'2023-01-15'"}, {"input": ["'15-Jan-2023'", "'%d-%b-%Y'", "'%B %d, %Y'"], "expected_output": "'January 15, 2023'"}], "failure": [{"input": [123, "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Date string must be a string"}, {"input": ["''", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Date string cannot be empty"}, {"input": ["'2023-01-15'", 123, "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Input format must be a string"}, {"input": ["'2023-01-15'", "'%Y-%m-%d'", 123], "expected_exception": "AssertionError", "expected_message_part": "Output format must be a string"}, {"input": ["'2023/01/15'", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_exception": "ValueError", "expected_message_part": "Invalid date string"}]}}
{"title": "ネットワークURLからドメイン名を抽出する関数", "description": "URLからドメイン名を抽出する関数に、アサーションとデバッグプリントを追加しました。この関数は、URLの形式チェックとパース処理の流れを明確にするためのデバッグプリントを含み、入力引数のバリデーションに関するアサーションを実装しています。このパターンは、文字列処理や正規表現を使用する関数で、特に外部入力値の検証が重要な場合に効果的です。", "keywords": ["url", "domain", "re.match", "regex", "string processing"], "code_before": "import re\n\ndef extract_domain(url):\n    if url.startswith('http'):\n        # Remove protocol\n        url = url.split('://', 1)[1]\n    \n    # Remove path, query parameters, etc.\n    domain = url.split('/', 1)[0]\n    \n    # Remove port if present\n    if ':' in domain:\n        domain = domain.split(':', 1)[0]\n    \n    return domain", "code_after": "import re\n\ndef extract_domain(url):\n    print(f\"Starting domain extraction for URL: {url}\")\n    \n    # Input validation\n    assert isinstance(url, str), \"URL must be a string\"\n    assert url.strip() != \"\", \"URL cannot be empty\"\n    assert re.match(r'^(https?://)?([\\w.-]+)(:\\d+)?(/.*)?$', url), f\"Invalid URL format: {url}\"\n    \n    print(f\"URL validation passed for: {url}\")\n    \n    if url.startswith('http'):\n        # Remove protocol\n        url = url.split('://', 1)[1]\n        print(f\"Removed protocol, now processing: {url}\")\n    else:\n        print(f\"No protocol to remove, continuing with: {url}\")\n    \n    # Remove path, query parameters, etc.\n    domain = url.split('/', 1)[0]\n    print(f\"After removing path: {domain}\")\n    \n    # Remove port if present\n    if ':' in domain:\n        domain = domain.split(':', 1)[0]\n        print(f\"Port removed, domain is now: {domain}\")\n    else:\n        print(f\"No port to remove from domain: {domain}\")\n    \n    # Final validation\n    assert len(domain) > 0, \"Extracted domain cannot be empty\"\n    assert '.' in domain, f\"Extracted domain appears invalid (no dots): {domain}\"\n    \n    print(f\"Domain extraction complete. Result: {domain}\")\n    return domain", "test_cases": {"success": [{"input": ["'https://www.example.com/path/to/page?query=param'"], "expected_output": "'www.example.com'"}, {"input": ["'example.com'"], "expected_output": "'example.com'"}, {"input": ["'http://test-domain.co.uk:8080/'"], "expected_output": "'test-domain.co.uk'"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "URL must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "URL cannot be empty"}, {"input": ["'invalid@url'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid URL format"}, {"input": ["'http://'"], "expected_exception": "AssertionError", "expected_message_part": "Extracted domain cannot be empty"}, {"input": ["'localhost'"], "expected_exception": "AssertionError", "expected_message_part": "Extracted domain appears invalid (no dots)"}]}}
{"title": "CSVデータをリストに変換する関数", "description": "CSV形式の文字列をPythonのリストに変換する関数です。入力形式の検証のためのアサーションとデータ処理フローを追跡するためのデバッグプリントを追加しました。特に入力データの空チェックや区切り文字の存在確認を行い、各行の処理状況を詳細に出力します。このパターンはテキスト処理や構造化データの変換を行う関数に適用でき、特に複数の行や列を持つデータを扱う際に役立ちます。", "keywords": ["csv", "parsing", "split", "data conversion", "text processing"], "code_before": "def csv_to_list(csv_data, delimiter=',', has_header=True):\n    lines = csv_data.strip().split('\\n')\n    result = []\n    \n    for i, line in enumerate(lines):\n        if i == 0 and has_header:\n            continue\n        \n        values = line.split(delimiter)\n        result.append(values)\n    \n    return result", "code_after": "def csv_to_list(csv_data, delimiter=',', has_header=True):\n    print(f\"Starting CSV conversion with delimiter='{delimiter}', has_header={has_header}\")\n    \n    # Input validation\n    assert isinstance(csv_data, str), \"CSV data must be a string\"\n    assert isinstance(delimiter, str), \"Delimiter must be a string\"\n    assert len(delimiter) > 0, \"Delimiter cannot be empty\"\n    assert isinstance(has_header, bool), \"has_header must be a boolean\"\n    \n    # Check if CSV data is not empty\n    assert csv_data.strip(), \"CSV data cannot be empty\"\n    \n    # Process the data\n    lines = csv_data.strip().split('\\n')\n    print(f\"Found {len(lines)} lines in CSV data\")\n    \n    # Check if there's enough data when header is expected\n    if has_header:\n        assert len(lines) > 1, \"CSV with header must contain at least 2 lines\"\n    \n    result = []\n    \n    for i, line in enumerate(lines):\n        print(f\"Processing line {i+1}: {line[:50]}{'...' if len(line) > 50 else ''}\")\n        \n        # Skip header if specified\n        if i == 0 and has_header:\n            print(f\"Skipping header line: {line}\")\n            continue\n        \n        # Ensure the line contains the delimiter\n        if delimiter not in line and len(lines) > 1:\n            print(f\"Warning: Line {i+1} does not contain the delimiter '{delimiter}'\")\n        \n        values = line.split(delimiter)\n        print(f\"Line {i+1} split into {len(values)} values: {values[:3]}{'...' if len(values) > 3 else ''}\")\n        \n        result.append(values)\n    \n    print(f\"CSV conversion complete. Converted {len(result)} records\")\n    return result", "test_cases": {"success": [{"input": ["'name,age,city\\nAlice,30,New York\\nBob,25,Boston\\nCharlie,35,Chicago'", "','", "True"], "expected_output": "[['Alice', '30', 'New York'], ['Bob', '25', 'Boston'], ['Charlie', '35', 'Chicago']]"}, {"input": ["'Alice,30,New York\\nBob,25,Boston'", "','", "False"], "expected_output": "[['Alice', '30', 'New York'], ['Bob', '25', 'Boston']]"}, {"input": ["'name|age|city\\nAlice|30|New York'", "'|'", "True"], "expected_output": "[['Alice', '30', 'New York']]"}], "failure": [{"input": [123, "','", "True"], "expected_exception": "AssertionError", "expected_message_part": "CSV data must be a string"}, {"input": ["'data'", 123, "True"], "expected_exception": "AssertionError", "expected_message_part": "Delimiter must be a string"}, {"input": ["'data'", "''", "True"], "expected_exception": "AssertionError", "expected_message_part": "Delimiter cannot be empty"}, {"input": ["'data'", "','", "'yes'"], "expected_exception": "AssertionError", "expected_message_part": "has_header must be a boolean"}, {"input": ["''", "','", "True"], "expected_exception": "AssertionError", "expected_message_part": "CSV data cannot be empty"}, {"input": ["'header_only'", "','", "True"], "expected_exception": "AssertionError", "expected_message_part": "CSV with header must contain at least 2 lines"}]}}
{"title": "画像ファイルのリサイズ関数", "description": "画像リサイズ関数に対して、入力パラメータの検証とリサイズ処理の各ステップでの状態確認のためのアサーションとデバッグプリントを挿入しています。入力が画像ファイルパスとサイズであり、出力が成功または失敗を表す真偽値である関数において、このパターンは特に有効です。", "keywords": ["image", "resize", "file", "path", "dimensions", "PIL", "os.path"], "code_before": "def resize_image(image_path, width, height):\n    try:\n        from PIL import Image\n        img = Image.open(image_path)\n        resized_img = img.resize((width, height))\n        output_path = f\"{os.path.splitext(image_path)[0]}_resized{os.path.splitext(image_path)[1]}\"\n        resized_img.save(output_path)\n        return True\n    except Exception as e:\n        print(f\"Error resizing image: {e}\")\n        return False", "code_after": "import os\nimport logging\nfrom typing import Union, Tuple\n\ndef resize_image(image_path: str, width: int, height: int) -> bool:\n    \"\"\"Resize an image to specified dimensions and save the result.\n    \n    Args:\n        image_path: Path to the image file\n        width: Target width in pixels\n        height: Target height in pixels\n        \n    Returns:\n        bool: True if successful, False otherwise\n    \"\"\"\n    print(f\"[DEBUG] Starting resize_image with params: image_path={image_path}, width={width}, height={height}\")\n    \n    # Validate inputs\n    assert isinstance(image_path, str), f\"Image path must be a string, got {type(image_path)}\"\n    assert os.path.exists(image_path), f\"Image file does not exist: {image_path}\"\n    assert isinstance(width, int) and width > 0, f\"Width must be a positive integer, got {width}\"\n    assert isinstance(height, int) and height > 0, f\"Height must be a positive integer, got {height}\"\n    \n    try:\n        from PIL import Image\n        print(f\"[DEBUG] Opening image from {image_path}\")\n        img = Image.open(image_path)\n        \n        print(f\"[DEBUG] Original image size: {img.size}\")\n        print(f\"[DEBUG] Resizing image to {width}x{height}\")\n        resized_img = img.resize((width, height))\n        \n        # Verify resize was successful\n        assert resized_img.size == (width, height), f\"Resize failed: expected size {(width, height)}, got {resized_img.size}\"\n        \n        output_path = f\"{os.path.splitext(image_path)[0]}_resized{os.path.splitext(image_path)[1]}\"\n        print(f\"[DEBUG] Saving resized image to {output_path}\")\n        resized_img.save(output_path)\n        \n        print(f\"[DEBUG] Image successfully resized and saved to {output_path}\")\n        return True\n    except Exception as e:\n        print(f\"[ERROR] Error resizing image: {e}\")\n        return False", "test_cases": {"success": [{"input": ["'test_image.jpg'", "800", "600"], "expected_output": "True"}], "failure": [{"input": ["123", "800", "600"], "expected_exception": "AssertionError", "expected_message_part": "Image path must be a string"}, {"input": ["'nonexistent_image.jpg'", "800", "600"], "expected_exception": "AssertionError", "expected_message_part": "Image file does not exist"}, {"input": ["'test_image.jpg'", "-100", "600"], "expected_exception": "AssertionError", "expected_message_part": "Width must be a positive integer"}, {"input": ["'test_image.jpg'", "800", "0"], "expected_exception": "AssertionError", "expected_message_part": "Height must be a positive integer"}]}}
{"title": "JSONデータのバリデーション関数", "description": "JSONデータが特定のスキーマに準拠しているかを検証する関数に対して、入力検証と処理段階ごとのデバッグプリントを追加しています。このパターンは、外部から受け取るJSONデータを処理する前に、その構造と内容を確認する必要がある場合に特に有効です。", "keywords": ["json", "validation", "schema", "dictionary", "nested", "data", "check"], "code_before": "def validate_user_json(user_data):\n    if not user_data:\n        return False\n    \n    required_fields = ['name', 'email', 'age']\n    for field in required_fields:\n        if field not in user_data:\n            return False\n    \n    if not isinstance(user_data['name'], str) or len(user_data['name']) < 2:\n        return False\n    \n    if not isinstance(user_data['email'], str) or '@' not in user_data['email']:\n        return False\n    \n    if not isinstance(user_data['age'], int) or user_data['age'] < 18:\n        return False\n    \n    return True", "code_after": "def validate_user_json(user_data):\n    \"\"\"Validates user JSON data against a predefined schema.\n    \n    Args:\n        user_data (dict): The user data to validate\n        \n    Returns:\n        bool: True if the data is valid, False otherwise\n    \"\"\"\n    print(f\"[DEBUG] Starting validation of user data: {user_data}\")\n    \n    # Check if user_data is provided and is a dictionary\n    assert user_data is not None, \"User data cannot be None\"\n    assert isinstance(user_data, dict), f\"User data must be a dictionary, got {type(user_data)}\"\n    \n    if not user_data:\n        print(\"[DEBUG] User data is empty\")\n        return False\n    \n    # Validate required fields exist\n    required_fields = ['name', 'email', 'age']\n    print(f\"[DEBUG] Checking for required fields: {required_fields}\")\n    for field in required_fields:\n        if field not in user_data:\n            print(f\"[DEBUG] Missing required field: {field}\")\n            return False\n        print(f\"[DEBUG] Found field: {field} = {user_data[field]}\")\n    \n    # Validate name field\n    print(f\"[DEBUG] Validating name: {user_data['name']}\")\n    if not isinstance(user_data['name'], str):\n        print(f\"[DEBUG] Name is not a string: {type(user_data['name'])}\")\n        return False\n    \n    if len(user_data['name']) < 2:\n        print(f\"[DEBUG] Name is too short: {len(user_data['name'])} chars\")\n        return False\n    \n    # Validate email field\n    print(f\"[DEBUG] Validating email: {user_data['email']}\")\n    if not isinstance(user_data['email'], str):\n        print(f\"[DEBUG] Email is not a string: {type(user_data['email'])}\")\n        return False\n    \n    if '@' not in user_data['email']:\n        print(f\"[DEBUG] Invalid email format: {user_data['email']}\")\n        return False\n    \n    # Validate age field\n    print(f\"[DEBUG] Validating age: {user_data['age']}\")\n    if not isinstance(user_data['age'], int):\n        print(f\"[DEBUG] Age is not an integer: {type(user_data['age'])}\")\n        return False\n    \n    if user_data['age'] < 18:\n        print(f\"[DEBUG] User is underage: {user_data['age']}\")\n        return False\n    \n    print(\"[DEBUG] User data validation successful\")\n    return True", "test_cases": {"success": [{"input": ["{\"name\": \"John Doe\", \"email\": \"john@example.com\", \"age\": 25}"], "expected_output": "True"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "User data cannot be None"}, {"input": ["[1, 2, 3]"], "expected_exception": "AssertionError", "expected_message_part": "User data must be a dictionary"}, {"input": ["{}"], "expected_output": "False"}, {"input": ["{\"name\": \"John Doe\", \"age\": 25}"], "expected_output": "False"}, {"input": ["{\"name\": 123, \"email\": \"john@example.com\", \"age\": 25}"], "expected_output": "False"}, {"input": ["{\"name\": \"J\", \"email\": \"john@example.com\", \"age\": 25}"], "expected_output": "False"}, {"input": ["{\"name\": \"John Doe\", \"email\": \"johnexample.com\", \"age\": 25}"], "expected_output": "False"}, {"input": ["{\"name\": \"John Doe\", \"email\": \"john@example.com\", \"age\": 16}"], "expected_output": "False"}]}}
{"title": "配列の重複要素を削除する関数", "description": "リストの重複を削除する関数に対して、入力検証とデバッグ情報を追加しました。このパターンは、リストを操作する関数に適用できます。入力がリストであることを確認し、処理の各ステップで状態を出力することで、デバッグ作業が容易になります。", "keywords": ["list", "set", "unique", "duplicate", "remove"], "code_before": "def remove_duplicates(items):\n    unique_items = []\n    for item in items:\n        if item not in unique_items:\n            unique_items.append(item)\n    return unique_items", "code_after": "def remove_duplicates(items):\n    print(f\"Starting remove_duplicates with items: {items}\")\n    \n    # アサーション: 入力がリストまたはタプルであることを確認\n    assert isinstance(items, (list, tuple)), f\"Expected list or tuple, got {type(items).__name__}\"\n    \n    # アサーション: 空でない入力を確認\n    assert len(items) > 0, \"Input list cannot be empty\"\n    \n    unique_items = []\n    print(f\"Initialized empty unique_items list\")\n    \n    for i, item in enumerate(items):\n        print(f\"Processing item {i}: {item}\")\n        if item not in unique_items:\n            print(f\"  Adding {item} to unique_items\")\n            unique_items.append(item)\n        else:\n            print(f\"  Skipping duplicate {item}\")\n    \n    print(f\"Completed processing. Unique items: {unique_items}\")\n    return unique_items", "test_cases": {"success": [{"input": ["[1, 2, 2, 3, 4, 4, 5]"], "expected_output": "[1, 2, 3, 4, 5]"}, {"input": ["['apple', 'banana', 'apple', 'orange', 'banana']"], "expected_output": "['apple', 'banana', 'orange']"}], "failure": [{"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "Expected list or tuple"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "Input list cannot be empty"}]}}
{"title": "数値の四則演算処理関数", "description": "数値演算を行う関数に対して、入力値と演算子の検証、および処理の各ステップでのデバッグ情報を追加しました。このパターンは、複数の入力パラメータを持ち、特定の条件下で例外が発生する可能性がある関数に適用できます。", "keywords": ["arithmetic", "calculation", "operator", "validation", "division"], "code_before": "def calculate(a, b, operation):\n    if operation == '+':\n        return a + b\n    elif operation == '-':\n        return a - b\n    elif operation == '*':\n        return a * b\n    elif operation == '/':\n        return a / b\n    else:\n        return None", "code_after": "def calculate(a, b, operation):\n    print(f\"Starting calculation with a={a}, b={b}, operation='{operation}'\")\n    \n    # アサーション: 数値型のチェック\n    assert isinstance(a, (int, float)), f\"First argument must be a number, got {type(a).__name__}\"\n    assert isinstance(b, (int, float)), f\"Second argument must be a number, got {type(b).__name__}\"\n    \n    # アサーション: 操作子の検証\n    valid_operations = ['+', '-', '*', '/']\n    assert operation in valid_operations, f\"Operation must be one of {valid_operations}, got '{operation}'\"\n    \n    # アサーション: ゼロ除算の防止\n    if operation == '/':\n        assert b != 0, \"Division by zero is not allowed\"\n    \n    print(f\"All input validations passed, proceeding with calculation\")\n    \n    result = None\n    if operation == '+':\n        print(f\"Performing addition: {a} + {b}\")\n        result = a + b\n    elif operation == '-':\n        print(f\"Performing subtraction: {a} - {b}\")\n        result = a - b\n    elif operation == '*':\n        print(f\"Performing multiplication: {a} * {b}\")\n        result = a * b\n    elif operation == '/':\n        print(f\"Performing division: {a} / {b}\")\n        result = a / b\n    \n    print(f\"Calculation complete. Result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["10", "5", "'+'"], "expected_output": "15"}, {"input": ["10", "5", "'-'"], "expected_output": "5"}, {"input": ["10", "5", "'*'"], "expected_output": "50"}, {"input": ["10", "5", "'/'"], "expected_output": "2.0"}], "failure": [{"input": ["'10'", "5", "'+'"], "expected_exception": "AssertionError", "expected_message_part": "First argument must be a number"}, {"input": ["10", "'5'", "'+'"], "expected_exception": "AssertionError", "expected_message_part": "Second argument must be a number"}, {"input": ["10", "5", "'%'"], "expected_exception": "AssertionError", "expected_message_part": "Operation must be one of"}, {"input": ["10", "0", "'/'"], "expected_exception": "AssertionError", "expected_message_part": "Division by zero is not allowed"}]}}
{"title": "ユーザープロファイル検証関数", "description": "ユーザープロファイルの必須フィールドとデータ型を検証する関数に対して、アサーションとデバッグ情報を追加しました。このパターンは、辞書形式のデータ構造を検証する際に有効です。また、入れ子になったデータや特定のフィールドの存在確認にも応用できます。", "keywords": ["dictionary", "validation", "user", "profile", "nested"], "code_before": "def validate_user_profile(profile):\n    if not all(k in profile for k in ['name', 'email', 'age']):\n        return False\n    if not isinstance(profile['name'], str) or not profile['name']:\n        return False\n    if not isinstance(profile['email'], str) or '@' not in profile['email']:\n        return False\n    if not isinstance(profile['age'], int) or profile['age'] < 18:\n        return False\n    return True", "code_after": "def validate_user_profile(profile):\n    print(f\"Starting user profile validation: {profile}\")\n    \n    # アサーション: 入力が辞書であることを確認\n    assert isinstance(profile, dict), f\"Profile must be a dictionary, got {type(profile).__name__}\"\n    \n    # 必須フィールドの存在確認\n    required_fields = ['name', 'email', 'age']\n    print(f\"Checking required fields: {required_fields}\")\n    \n    for field in required_fields:\n        print(f\"Checking if '{field}' exists in profile\")\n        assert field in profile, f\"Required field '{field}' is missing from profile\"\n    \n    print(\"All required fields present, validating individual fields\")\n    \n    # 名前のバリデーション\n    print(f\"Validating name: {profile['name']}\")\n    assert isinstance(profile['name'], str), f\"Name must be a string, got {type(profile['name']).__name__}\"\n    assert profile['name'].strip(), \"Name cannot be empty or whitespace only\"\n    \n    # メールアドレスのバリデーション\n    print(f\"Validating email: {profile['email']}\")\n    assert isinstance(profile['email'], str), f\"Email must be a string, got {type(profile['email']).__name__}\"\n    assert '@' in profile['email'], \"Email must contain '@' symbol\"\n    \n    # 年齢のバリデーション\n    print(f\"Validating age: {profile['age']}\")\n    assert isinstance(profile['age'], int), f\"Age must be an integer, got {type(profile['age']).__name__}\"\n    assert profile['age'] >= 18, f\"User must be at least 18 years old, got {profile['age']}\"\n    \n    print(\"All validations passed successfully!\")\n    return True", "test_cases": {"success": [{"input": ["{'name': 'John Doe', 'email': 'john@example.com', 'age': 25}"], "expected_output": "True"}, {"input": ["{'name': 'Alice Smith', 'email': 'alice.smith@company.org', 'age': 18, 'extra_field': 'extra_value'}"], "expected_output": "True"}], "failure": [{"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "Profile must be a dictionary"}, {"input": ["{'name': 'John Doe', 'email': 'john@example.com'}"], "expected_exception": "AssertionError", "expected_message_part": "Required field 'age' is missing"}, {"input": ["{'name': 123, 'email': 'john@example.com', 'age': 25}"], "expected_exception": "AssertionError", "expected_message_part": "Name must be a string"}, {"input": ["{'name': '', 'email': 'john@example.com', 'age': 25}"], "expected_exception": "AssertionError", "expected_message_part": "Name cannot be empty"}, {"input": ["{'name': 'John Doe', 'email': 'invalid-email', 'age': 25}"], "expected_exception": "AssertionError", "expected_message_part": "Email must contain '@' symbol"}, {"input": ["{'name': 'John Doe', 'email': 'john@example.com', 'age': 17}"], "expected_exception": "AssertionError", "expected_message_part": "User must be at least 18 years old"}]}}
