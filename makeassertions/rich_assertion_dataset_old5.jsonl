{"title": "リスト内の要素を指定した値で除算する関数", "description": "数値リストの各要素を指定された除数で割る関数です。アサーションにより入力がリストであることや除数が0でないことを検証し、デバッグプリントによって処理の各ステップと中間値を追跡しています。このパターンは入力検証と複数の中間ステップを持つ処理の可視化に有効です。", "keywords": ["list", "division", "for loop", "float", "zero division"], "code_before": "def divide_list(numbers, divisor):\n    result = []\n    for num in numbers:\n        result.append(num / divisor)\n    return result", "code_after": "def divide_list(numbers, divisor):\n    print(f\"[START] divide_list called with numbers={numbers}, divisor={divisor}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), f\"Expected 'numbers' to be a list, got {type(numbers).__name__}\"\n    assert divisor != 0, \"Divisor cannot be zero (division by zero)\"\n    \n    print(f\"Input validation passed. Processing {len(numbers)} elements...\")\n    \n    result = []\n    for i, num in enumerate(numbers):\n        print(f\"  Processing element {i}: {num}\")\n        # 数値か検証\n        assert isinstance(num, (int, float)), f\"Element at index {i} is not a number: {type(num).__name__}\"\n        \n        value = num / divisor\n        print(f\"  {num} / {divisor} = {value}\")\n        result.append(value)\n    \n    print(f\"[END] divide_list returning: {result}\")\n    return result", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]", "2"], "expected_output": "[0.5, 1.0, 1.5, 2.0, 2.5]"}, {"input": ["[-10, 0, 10]", "5"], "expected_output": "[-2.0, 0.0, 2.0]"}], "failure": [{"input": ["'not a list'", "2"], "expected_exception": "AssertionError", "expected_message_part": "Expected 'numbers' to be a list"}, {"input": ["[1, 2, 'string', 4]", "2"], "expected_exception": "AssertionError", "expected_message_part": "Element at index 2 is not a number"}, {"input": ["[1, 2, 3]", "0"], "expected_exception": "AssertionError", "expected_message_part": "Divisor cannot be zero"}]}}
{"title": "辞書から値を安全に取得する関数", "description": "このパターンは辞書操作で特に重要です。アサーションを使って引数の型を検証し、デバッグプリントでキーの検索状況と結果を追跡します。デフォルト値の扱いや存在しないキーのハンドリングなど、辞書操作の安全性を高めるために有効です。", "keywords": ["dict", "get", "default", "key validation", "KeyError"], "code_before": "def get_value(dictionary, key, default=None):\n    if key in dictionary:\n        return dictionary[key]\n    return default", "code_after": "def get_value(dictionary, key, default=None):\n    print(f\"[START] get_value called with key='{key}', default={default}\")\n    \n    # 引数の検証\n    assert isinstance(dictionary, dict), f\"First argument must be a dictionary, got {type(dictionary).__name__}\"\n    assert key is not None, \"Key cannot be None\"\n    \n    print(f\"Dictionary has {len(dictionary)} entries: {list(dictionary.keys())}\")\n    \n    if key in dictionary:\n        value = dictionary[key]\n        print(f\"Key '{key}' found in dictionary with value: {value}\")\n        print(f\"[END] Returning found value: {value}\")\n        return value\n    else:\n        print(f\"Key '{key}' not found in dictionary\")\n        print(f\"[END] Returning default value: {default}\")\n        return default", "test_cases": {"success": [{"input": ["{'a': 1, 'b': 2, 'c': 3}", "'b'", "None"], "expected_output": "2"}, {"input": ["{'x': 'hello'}", "'y'", "'world'"], "expected_output": "'world'"}], "failure": [{"input": ["[1, 2, 3]", "'key'", "None"], "expected_exception": "AssertionError", "expected_message_part": "First argument must be a dictionary"}, {"input": ["{'a': 1}", "None", "0"], "expected_exception": "AssertionError", "expected_message_part": "Key cannot be None"}]}}
{"title": "テキストファイルの行数と単語数をカウントする関数", "description": "ファイル操作関数では、ファイルパスの存在やアクセス権などの事前条件をアサーションで検証し、ファイル処理の各ステップをデバッグプリントで追跡することが重要です。このパターンはファイル処理の安全性と透明性を確保する際に役立ちます。", "keywords": ["file", "open", "read", "count", "os.path", "split", "with statement"], "code_before": "def count_file_stats(filepath):\n    line_count = 0\n    word_count = 0\n    with open(filepath, 'r') as file:\n        for line in file:\n            line_count += 1\n            words = line.split()\n            word_count += len(words)\n    return {'lines': line_count, 'words': word_count}", "code_after": "import os\n\ndef count_file_stats(filepath):\n    print(f\"[START] count_file_stats called with filepath='{filepath}'\")\n    \n    # ファイルパスの検証\n    assert isinstance(filepath, str), f\"Filepath must be a string, got {type(filepath).__name__}\"\n    assert os.path.exists(filepath), f\"File does not exist: '{filepath}'\"\n    assert os.path.isfile(filepath), f\"Path is not a file: '{filepath}'\"\n    assert os.access(filepath, os.R_OK), f\"File is not readable: '{filepath}'\"\n    \n    file_size = os.path.getsize(filepath)\n    print(f\"File '{filepath}' exists (size: {file_size} bytes). Starting to process...\")\n    \n    line_count = 0\n    word_count = 0\n    \n    try:\n        with open(filepath, 'r') as file:\n            print(f\"File opened successfully in read mode\")\n            for line_num, line in enumerate(file, 1):\n                line_count += 1\n                words = line.split()\n                word_count += len(words)\n                print(f\"  Line {line_num}: {len(words)} words\")\n    except Exception as e:\n        print(f\"[ERROR] Error while reading file: {str(e)}\")\n        raise\n    \n    result = {'lines': line_count, 'words': word_count}\n    print(f\"[END] count_file_stats returning: {result}\")\n    return result", "test_cases": {"success": [{"input": ["'sample.txt'"], "expected_output": "{'lines': 3, 'words': 10}"}, {"input": ["'empty.txt'"], "expected_output": "{'lines': 0, 'words': 0}"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Filepath must be a string"}, {"input": ["'nonexistent_file.txt'"], "expected_exception": "AssertionError", "expected_message_part": "File does not exist"}, {"input": ["'directory/'"], "expected_exception": "AssertionError", "expected_message_part": "Path is not a file"}]}}
{"title": "文字列内の特定のパターンを置換する関数", "description": "正規表現を使用した文字列処理関数では、入力の型チェックだけでなく、パターンと置換テキストの妥当性も検証することが重要です。このパターンはテキスト処理の透明性を高め、予期せぬ正規表現エラーを防ぐのに役立ちます。", "keywords": ["string", "regex", "replace", "re.sub", "pattern matching"], "code_before": "import re\n\ndef replace_pattern(text, pattern, replacement):\n    return re.sub(pattern, replacement, text)", "code_after": "import re\n\ndef replace_pattern(text, pattern, replacement):\n    print(f\"[START] replace_pattern called with:\")\n    print(f\"  text: '{text}'\")\n    print(f\"  pattern: '{pattern}'\")\n    print(f\"  replacement: '{replacement}'\")\n    \n    # 入力検証\n    assert isinstance(text, str), f\"Text must be a string, got {type(text).__name__}\"\n    assert isinstance(pattern, str), f\"Pattern must be a string, got {type(pattern).__name__}\"\n    assert isinstance(replacement, str), f\"Replacement must be a string, got {type(replacement).__name__}\"\n    \n    # 空文字列のチェック\n    if not text:\n        print(f\"Warning: Input text is empty\")\n        return \"\"\n    \n    # 有効な正規表現パターンか確認\n    try:\n        re.compile(pattern)\n        print(f\"Pattern '{pattern}' is a valid regex pattern\")\n    except re.error as e:\n        error_msg = f\"Invalid regex pattern: {str(e)}\"\n        print(f\"[ERROR] {error_msg}\")\n        assert False, error_msg\n    \n    # 置換処理の実行\n    try:\n        print(f\"Performing replacement...\")\n        result = re.sub(pattern, replacement, text)\n        \n        # 置換が行われたかをカウント\n        matches = re.findall(pattern, text)\n        match_count = len(matches)\n        print(f\"Found {match_count} matches of the pattern\")\n        \n        print(f\"Original length: {len(text)}, New length: {len(result)}\")\n        print(f\"[END] replace_pattern returning: '{result}'\")\n        return result\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error during replacement: {str(e)}\")\n        raise", "test_cases": {"success": [{"input": ["'Hello, world!'", "'world'", "'Python'"], "expected_output": "'Hello, Python!'"}, {"input": ["'aaa bbb ccc'", "'b+'", "'X'"], "expected_output": "'aaa X ccc'"}], "failure": [{"input": [123, "'pattern'", "'replacement'"], "expected_exception": "AssertionError", "expected_message_part": "Text must be a string"}, {"input": ["'text'", "'('", "'replacement'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid regex pattern"}, {"input": ["'text'", "'pattern'", 42], "expected_exception": "AssertionError", "expected_message_part": "Replacement must be a string"}]}}
{"title": "年齢から世代を判定する関数", "description": "ユーザーの年齢を受け取り、適切な世代カテゴリを返す関数です。入力値の型チェックと範囲チェックのアサーションが重要です。また、条件分岐の多い関数では各分岐に入ったことを確認するデバッグプリントが有効です。", "keywords": ["if-elif-else", "条件分岐", "入力検証", "型チェック"], "code_before": "def get_generation(age):\n    if age < 13:\n        return \"Child\"\n    elif age < 20:\n        return \"Teenager\"\n    elif age < 40:\n        return \"Adult\"\n    elif age < 65:\n        return \"Middle-aged\"\n    else:\n        return \"Senior\"", "code_after": "def get_generation(age):\n    print(f\"[DEBUG] Starting get_generation with age: {age}\")\n    \n    # アサーション: 年齢は整数型であること\n    assert isinstance(age, (int, float)), f\"Age must be a number, got {type(age)}\"\n    \n    # アサーション: 年齢は正の値であること\n    assert age >= 0, f\"Age must be non-negative, got {age}\"\n    \n    # アサーション: 年齢は現実的な値であること（例: 150歳以下）\n    assert age <= 150, f\"Age exceeds reasonable human age limit: {age}\"\n    \n    if age < 13:\n        print(f\"[DEBUG] Classified as Child: {age} years old\")\n        return \"Child\"\n    elif age < 20:\n        print(f\"[DEBUG] Classified as Teenager: {age} years old\")\n        return \"Teenager\"\n    elif age < 40:\n        print(f\"[DEBUG] Classified as Adult: {age} years old\")\n        return \"Adult\"\n    elif age < 65:\n        print(f\"[DEBUG] Classified as Middle-aged: {age} years old\")\n        return \"Middle-aged\"\n    else:\n        print(f\"[DEBUG] Classified as Senior: {age} years old\")\n        return \"Senior\"", "test_cases": {"success": [{"input": ["10"], "expected_output": "\"Child\""}, {"input": ["18"], "expected_output": "\"Teenager\""}, {"input": ["35"], "expected_output": "\"Adult\""}, {"input": ["70"], "expected_output": "\"Senior\""}], "failure": [{"input": ["\"twenty\""], "expected_exception": "AssertionError", "expected_message_part": "Age must be a number"}, {"input": ["-5"], "expected_exception": "AssertionError", "expected_message_part": "Age must be non-negative"}, {"input": ["200"], "expected_exception": "AssertionError", "expected_message_part": "Age exceeds reasonable human age limit"}]}}
{"title": "温度単位変換関数（摂氏から華氏）", "description": "摂氏温度を華氏温度に変換する関数です。物理的な変換を行う関数では、入力値の型と範囲の検証が重要です。また、計算過程を追跡するデバッグプリントを入れることで、変換式が正しく適用されているか確認できます。", "keywords": ["数値計算", "単位変換", "型チェック", "範囲検証"], "code_before": "def celsius_to_fahrenheit(celsius):\n    fahrenheit = (celsius * 9/5) + 32\n    return fahrenheit", "code_after": "def celsius_to_fahrenheit(celsius):\n    print(f\"[DEBUG] Starting celsius_to_fahrenheit with value: {celsius}°C\")\n    \n    # アサーション: 温度は数値型であること\n    assert isinstance(celsius, (int, float)), f\"Temperature must be a number, got {type(celsius)}\"\n    \n    # アサーション: 温度は絶対零度（-273.15°C）以上であること\n    assert celsius >= -273.15, f\"Temperature below absolute zero: {celsius}°C\"\n    \n    # アサーション: 現実的な温度範囲内であること（例: 太陽の中心温度は約1500万°C）\n    assert celsius <= 15000000, f\"Temperature exceeds reasonable limit: {celsius}°C\"\n    \n    print(f\"[DEBUG] Calculating: ({celsius} * 9/5) + 32\")\n    fahrenheit = (celsius * 9/5) + 32\n    \n    print(f\"[DEBUG] Converted {celsius}°C to {fahrenheit}°F\")\n    return fahrenheit", "test_cases": {"success": [{"input": ["0"], "expected_output": "32.0"}, {"input": ["100"], "expected_output": "212.0"}, {"input": ["-40"], "expected_output": "-40.0"}, {"input": ["37"], "expected_output": "98.6"}], "failure": [{"input": ["\"room temperature\""], "expected_exception": "AssertionError", "expected_message_part": "Temperature must be a number"}, {"input": ["-300"], "expected_exception": "AssertionError", "expected_message_part": "Temperature below absolute zero"}, {"input": ["20000000"], "expected_exception": "AssertionError", "expected_message_part": "Temperature exceeds reasonable limit"}]}}
{"title": "URLからドメイン名を抽出する関数", "description": "URL文字列からドメイン名部分を抽出する関数です。文字列操作を行う関数では、入力値の型チェックとフォーマット検証が重要です。正規表現や文字列メソッドの処理段階を追跡するデバッグプリントも効果的です。", "keywords": ["文字列処理", "正規表現", "URL解析", "入力検証"], "code_before": "def extract_domain(url):\n    if url.startswith('http://') or url.startswith('https://'):\n        url = url.split('://', 1)[1]\n    \n    if '/' in url:\n        url = url.split('/', 1)[0]\n    \n    return url", "code_after": "def extract_domain(url):\n    print(f\"[DEBUG] Starting extract_domain with URL: {url}\")\n    \n    # アサーション: URLは文字列であること\n    assert isinstance(url, str), f\"URL must be a string, got {type(url)}\"\n    \n    # アサーション: URLは空でないこと\n    assert url.strip(), \"URL cannot be empty or whitespace\"\n    \n    # アサーション: URLに基本的な構造があること\n    assert '.' in url, f\"URL must contain at least one dot: {url}\"\n    \n    print(f\"[DEBUG] Checking if URL starts with http:// or https://\")\n    if url.startswith('http://') or url.startswith('https://'):\n        protocol = url.split('://', 1)[0]\n        url = url.split('://', 1)[1]\n        print(f\"[DEBUG] Removed protocol {protocol}://, remaining: {url}\")\n    else:\n        print(f\"[DEBUG] No protocol found in URL\")\n    \n    print(f\"[DEBUG] Checking if URL contains path component\")\n    if '/' in url:\n        domain = url.split('/', 1)[0]\n        path = url.split('/', 1)[1]\n        print(f\"[DEBUG] Extracted domain: {domain}, removed path: /{path}\")\n    else:\n        domain = url\n        print(f\"[DEBUG] No path component found, domain is: {domain}\")\n    \n    print(f\"[DEBUG] Final extracted domain: {domain}\")\n    return domain", "test_cases": {"success": [{"input": ["\"https://www.example.com/path/to/page\""], "expected_output": "\"www.example.com\""}, {"input": ["\"example.org\""], "expected_output": "\"example.org\""}, {"input": ["\"http://subdomain.example.net/page?query=value\""], "expected_output": "\"subdomain.example.net\""}, {"input": ["\"https://example.com:8080/path\""], "expected_output": "\"example.com:8080\""}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "URL must be a string"}, {"input": ["\"\""], "expected_exception": "AssertionError", "expected_message_part": "URL cannot be empty"}, {"input": ["\"invalid-url-without-dot\""], "expected_exception": "AssertionError", "expected_message_part": "URL must contain at least one dot"}]}}
