{"description": "ユーザー名とパスワードの検証を行う関数です。パスワードの長さや含まれる文字の種類をチェックし、ユーザー名との類似性も検証します。各チェックポイントで詳細なデバッグ情報を提供します。", "keywords": ["validation", "password", "security", "string processing", "regex"], "code_before": "def validate_password(username, password):\n    if len(password) < 8:\n        return False\n    if username.lower() in password.lower():\n        return False\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    return has_upper and has_lower and has_digit", "code_after": "def validate_password(username, password):\n    print(f\"開始: validate_password(username='{username}', password='{'*' * len(password)}')\")\n    \n    # 入力検証\n    assert isinstance(username, str), \"usernameは文字列である必要があります\"\n    assert isinstance(password, str), \"passwordは文字列である必要があります\"\n    assert len(username) > 0, \"usernameは空であってはなりません\"\n    \n    # パスワードの長さチェック\n    if len(password) < 8:\n        print(f\"  検証失敗: パスワードが短すぎます（{len(password)}文字）\")\n        return False\n    \n    print(f\"  検証成功: パスワードの長さは十分です（{len(password)}文字）\")\n    \n    # ユーザー名との類似性チェック\n    if username.lower() in password.lower():\n        print(f\"  検証失敗: パスワードにユーザー名が含まれています\")\n        return False\n    \n    print(f\"  検証成功: パスワードにユーザー名が含まれていません\")\n    \n    # 文字種類のチェック\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    print(f\"  文字種類チェック: 大文字={has_upper}, 小文字={has_lower}, 数字={has_digit}\")\n    \n    result = has_upper and has_lower and has_digit\n    print(f\"完了: 検証結果={result}\")\n    return result", "test_cases": {"success": [{"input": ["'john'", "'P@ssw0rd'"], "expected_output": "True"}, {"input": ["'alice'", "'Secur1tyMax'"], "expected_output": "True"}, {"input": ["'admin'", "'Adm1nistrat0R'"], "expected_output": "False"}], "failure": [{"input": [123, "'Password1'"], "expected_exception": "AssertionError", "expected_message_part": "usernameは文字列である必要があります"}, {"input": ["'user'", 12345], "expected_exception": "AssertionError", "expected_message_part": "passwordは文字列である必要があります"}, {"input": ["''", "'Password1'"], "expected_exception": "AssertionError", "expected_message_part": "usernameは空であってはなりません"}]}}
{"description": "辞書のリストから特定の条件に合致する要素をフィルタリングする関数です。対象となる辞書の構造と条件式の妥当性を厳密に検証し、処理過程を詳細にトレースします。", "keywords": ["dictionary", "filter", "list comprehension", "validation", "data processing"], "code_before": "def filter_data(data_list, key, min_value):\n    filtered = [item for item in data_list if item[key] >= min_value]\n    return filtered", "code_after": "def filter_data(data_list, key, min_value):\n    print(f\"開始: filter_data(data_list={data_list}, key='{key}', min_value={min_value})\")\n    \n    # 入力検証\n    assert isinstance(data_list, list), \"data_listはリスト型である必要があります\"\n    assert all(isinstance(item, dict) for item in data_list), \"data_listの全要素は辞書型である必要があります\"\n    assert isinstance(key, str), \"keyは文字列である必要があります\"\n    assert isinstance(min_value, (int, float)), \"min_valueは数値型である必要があります\"\n    \n    # キーの存在確認\n    for i, item in enumerate(data_list):\n        assert key in item, f\"インデックス {i} の要素に '{key}' キーが存在しません\"\n        assert isinstance(item[key], (int, float)), f\"インデックス {i} の要素の '{key}' の値は数値型である必要があります\"\n    \n    # フィルタリング処理\n    filtered = []\n    for i, item in enumerate(data_list):\n        if item[key] >= min_value:\n            print(f\"  要素 {i}: 値 {item[key]} >= {min_value} → 採用\")\n            filtered.append(item)\n        else:\n            print(f\"  要素 {i}: 値 {item[key]} < {min_value} → 除外\")\n    \n    print(f\"完了: フィルタリング結果={filtered}\")\n    return filtered", "test_cases": {"success": [{"input": ["[{'id': 1, 'score': 85}, {'id': 2, 'score': 70}, {'id': 3, 'score': 90}]", "'score'", "80"], "expected_output": "[{'id': 1, 'score': 85}, {'id': 3, 'score': 90}]"}, {"input": ["[{'id': 1, 'price': 100}, {'id': 2, 'price': 200}, {'id': 3, 'price': 150}]", "'price'", "150"], "expected_output": "[{'id': 2, 'price': 200}, {'id': 3, 'price': 150}]"}, {"input": ["[]", "'value'", "10"], "expected_output": "[]"}], "failure": [{"input": ["'not a list'", "'key'", "10"], "expected_exception": "AssertionError", "expected_message_part": "data_listはリスト型である必要があります"}, {"input": ["[{'id': 1}, 'not a dict']", "'id'", "5"], "expected_exception": "AssertionError", "expected_message_part": "data_listの全要素は辞書型である必要があります"}, {"input": ["[{'id': 1}, {'id': 2}]", "10", "5"], "expected_exception": "AssertionError", "expected_message_part": "keyは文字列である必要があります"}, {"input": ["[{'id': 1}, {'id': 2}]", "'price'", "5"], "expected_exception": "AssertionError", "expected_message_part": "インデックス 0 の要素に 'price' キーが存在しません"}, {"input": ["[{'id': 1, 'score': '85'}, {'id': 2, 'score': 70}]", "'score'", "80"], "expected_exception": "AssertionError", "expected_message_part": "インデックス 0 の要素の 'score' の値は数値型である必要があります"}]}}
{"description": "数値配列の中から最大値と最小値を見つけて、その差を計算する関数。数値型チェック、空配列チェックを含むアサーションと、処理の進行状況を示すデバッグプリントを追加。", "keywords": ["max", "min", "list", "assertion", "range", "numerical"], "code_before": "def calculate_range(numbers):\n    max_val = max(numbers)\n    min_val = min(numbers)\n    return max_val - min_val", "code_after": "def calculate_range(numbers):\n    print(f\"[DEBUG] Starting calculate_range with input: {numbers}\")\n    \n    # アサーション: 引数が存在し、リスト型または類似の反復可能オブジェクトであることを確認\n    assert numbers is not None, \"Input list cannot be None\"\n    assert hasattr(numbers, '__iter__'), \"Input must be an iterable (like list, tuple)\"\n    \n    # アサーション: リストが空でないことを確認\n    assert len(numbers) > 0, \"Input list cannot be empty\"\n    \n    # アサーション: すべての要素が数値型であることを確認\n    assert all(isinstance(x, (int, float)) for x in numbers), \"All elements must be numbers\"\n    \n    print(f\"[DEBUG] Finding max and min values in {numbers}\")\n    max_val = max(numbers)\n    min_val = min(numbers)\n    \n    print(f\"[DEBUG] Found max={max_val}, min={min_val}\")\n    result = max_val - min_val\n    \n    print(f\"[DEBUG] Calculated range: {result}\")\n    return result", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "4"}, {"input": ["[-10, 0, 10]"], "expected_output": "20"}, {"input": ["[3.14, 2.71, 1.618, 9.81]"], "expected_output": "8.192"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "Input list cannot be None"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "Input list cannot be empty"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}, {"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Input must be an iterable"}]}}
{"description": "ユーザーの年齢に基づいて、特定のサービスへのアクセス可否を判定する関数。年齢の妥当性チェックとともに、数値型や範囲の検証アサーションとデバッグプリントを追加。", "keywords": ["if", "conditional", "age", "validation", "access", "comparison"], "code_before": "def check_age_access(age, service_type):\n    if service_type == 'alcohol' and age >= 21:\n        return True\n    elif service_type == 'movie_r' and age >= 17:\n        return True\n    elif service_type == 'voting' and age >= 18:\n        return True\n    else:\n        return False", "code_after": "def check_age_access(age, service_type):\n    print(f\"[DEBUG] Starting check_age_access with age={age}, service_type={service_type}\")\n    \n    # アサーション: 年齢が数値であることを確認\n    assert isinstance(age, (int, float)), \"Age must be a number\"\n    \n    # アサーション: 年齢が正の値であることを確認\n    assert age >= 0, \"Age cannot be negative\"\n    \n    # アサーション: 年齢が現実的な値であることを確認\n    assert age <= 120, \"Age exceeds reasonable human age limit\"\n    \n    # アサーション: サービスタイプが有効な値であることを確認\n    valid_services = ['alcohol', 'movie_r', 'voting']\n    assert service_type in valid_services, f\"Invalid service type. Must be one of {valid_services}\"\n    \n    print(f\"[DEBUG] Checking access for service '{service_type}' with age {age}\")\n    \n    if service_type == 'alcohol' and age >= 21:\n        result = True\n        print(f\"[DEBUG] Access granted for alcohol: age {age} >= 21\")\n    elif service_type == 'movie_r' and age >= 17:\n        result = True\n        print(f\"[DEBUG] Access granted for R-rated movie: age {age} >= 17\")\n    elif service_type == 'voting' and age >= 18:\n        result = True\n        print(f\"[DEBUG] Access granted for voting: age {age} >= 18\")\n    else:\n        result = False\n        print(f\"[DEBUG] Access denied for {service_type}: age {age} is insufficient\")\n    \n    print(f\"[DEBUG] Returning result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["21", "'alcohol'"], "expected_output": "True"}, {"input": ["17", "'movie_r'"], "expected_output": "True"}, {"input": ["18", "'voting'"], "expected_output": "True"}, {"input": ["16", "'alcohol'"], "expected_output": "False"}], "failure": [{"input": ["'twenty'", "'alcohol'"], "expected_exception": "AssertionError", "expected_message_part": "Age must be a number"}, {"input": ["-5", "'voting'"], "expected_exception": "AssertionError", "expected_message_part": "Age cannot be negative"}, {"input": ["150", "'movie_r'"], "expected_exception": "AssertionError", "expected_message_part": "Age exceeds reasonable human age limit"}, {"input": ["18", "'driving'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid service type"}]}}
{"description": "辞書内の特定のキーパスから値を安全に取得する関数。キーパスが存在しない場合はデフォルト値を返す。辞書の妥当性チェック、キーパスのフォーマットチェックを含むアサーションとデバッグプリントを追加。", "keywords": ["dict", "get", "nested", "key path", "default", "dictionary traversal"], "code_before": "def safe_get_nested(data, key_path, default=None):\n    keys = key_path.split('.')\n    current = data\n    for key in keys:\n        if isinstance(current, dict) and key in current:\n            current = current[key]\n        else:\n            return default\n    return current", "code_after": "def safe_get_nested(data, key_path, default=None):\n    print(f\"[DEBUG] Starting safe_get_nested with key_path={key_path}\")\n    print(f\"[DEBUG] Input data: {data}\")\n    \n    # アサーション: データが辞書型であることを確認\n    assert isinstance(data, dict), \"Input data must be a dictionary\"\n    \n    # アサーション: キーパスが文字列であることを確認\n    assert isinstance(key_path, str), \"Key path must be a string\"\n    \n    # アサーション: キーパスが空でないことを確認\n    assert key_path.strip(), \"Key path cannot be empty\"\n    \n    # アサーション: キーパスのフォーマットが正しいことを確認\n    assert all(k.strip() for k in key_path.split('.')), \"Key path contains empty keys\"\n    \n    keys = key_path.split('.')\n    print(f\"[DEBUG] Parsed keys: {keys}\")\n    \n    current = data\n    for i, key in enumerate(keys):\n        print(f\"[DEBUG] Processing key[{i}]: '{key}'\")\n        if isinstance(current, dict) and key in current:\n            current = current[key]\n            print(f\"[DEBUG] Found value for '{key}': {current}\")\n        else:\n            print(f\"[DEBUG] Key '{key}' not found or parent is not a dict. Returning default: {default}\")\n            return default\n    \n    print(f\"[DEBUG] Successfully retrieved value: {current}\")\n    return current", "test_cases": {"success": [{"input": ["{\"user\": {\"name\": \"John\", \"address\": {\"city\": \"New York\"}}}", "'user.name'", "None"], "expected_output": "'John'"}, {"input": ["{\"user\": {\"name\": \"John\", \"address\": {\"city\": \"New York\"}}}", "'user.address.city'", "None"], "expected_output": "'New York'"}, {"input": ["{\"user\": {\"name\": \"John\", \"address\": {\"city\": \"New York\"}}}", "'user.age'", "'Unknown'"], "expected_output": "'Unknown'"}], "failure": [{"input": ["[1, 2, 3]", "'0'", "None"], "expected_exception": "AssertionError", "expected_message_part": "Input data must be a dictionary"}, {"input": ["{}", "123", "None"], "expected_exception": "AssertionError", "expected_message_part": "Key path must be a string"}, {"input": ["{}", "''", "None"], "expected_exception": "AssertionError", "expected_message_part": "Key path cannot be empty"}, {"input": ["{}", "'user..name'", "None"], "expected_exception": "AssertionError", "expected_message_part": "Key path contains empty keys"}]}}
{"description": "テキスト文字列を分析して、単語数、文字数、平均単語長を計算する関数。入力テキストの妥当性チェックと文字列型の検証を含むアサーションとデバッグプリントを追加。", "keywords": ["string", "text", "analysis", "count", "words", "characters", "split"], "code_before": "def analyze_text(text):\n    words = text.split()\n    word_count = len(words)\n    char_count = len(text)\n    avg_word_length = char_count / word_count if word_count > 0 else 0\n    \n    return {\n        'word_count': word_count,\n        'character_count': char_count,\n        'average_word_length': round(avg_word_length, 2)\n    }", "code_after": "def analyze_text(text):\n    print(f\"[DEBUG] Starting analyze_text with text: '{text[:30]}{'...' if len(text) > 30 else ''}'\")\n    \n    # アサーション: テキストが None でないことを確認\n    assert text is not None, \"Input text cannot be None\"\n    \n    # アサーション: テキストが文字列型であることを確認\n    assert isinstance(text, str), \"Input must be a string\"\n    \n    # アサーション: テキストが空でない場合にのみ分析を実行\n    if text.strip():\n        words = text.split()\n        print(f\"[DEBUG] Split text into {len(words)} words\")\n        \n        word_count = len(words)\n        char_count = len(text)\n        print(f\"[DEBUG] Character count: {char_count}\")\n        \n        # 0除算を防止するためのチェック\n        avg_word_length = char_count / word_count if word_count > 0 else 0\n        print(f\"[DEBUG] Calculated average word length: {avg_word_length}\")\n    else:\n        print(\"[DEBUG] Empty text received\")\n        word_count = 0\n        char_count = 0\n        avg_word_length = 0\n    \n    result = {\n        'word_count': word_count,\n        'character_count': char_count,\n        'average_word_length': round(avg_word_length, 2)\n    }\n    \n    print(f\"[DEBUG] Returning analysis result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["'Hello world, this is a test.'"], "expected_output": "{'word_count': 6, 'character_count': 27, 'average_word_length': 4.5}"}, {"input": ["'Short text'"], "expected_output": "{'word_count': 2, 'character_count': 10, 'average_word_length': 5.0}"}, {"input": ["''"], "expected_output": "{'word_count': 0, 'character_count': 0, 'average_word_length': 0}"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "Input text cannot be None"}, {"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a string"}]}}
{"description": "リスト内の特定の数値よりも大きい要素を抽出する関数で、入力リストの検証と処理の追跡を行います。この関数では引数の型チェック、リストの空チェック、閾値の数値チェックを行い、処理の流れをデバッグプリントで明示します。", "keywords": ["list comprehension", "filter", "assert", "isinstance", "debug"], "code_before": "def filter_numbers(numbers, threshold):\n    return [num for num in numbers if num > threshold]", "code_after": "def filter_numbers(numbers, threshold):\n    print(f\"DEBUG: Starting filter_numbers with threshold={threshold}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), f\"Expected list, got {type(numbers).__name__}\"\n    assert len(numbers) > 0, \"Input list cannot be empty\"\n    assert isinstance(threshold, (int, float)), f\"Threshold must be a number, got {type(threshold).__name__}\"\n    \n    print(f\"DEBUG: Processing list of length {len(numbers)}\")\n    result = [num for num in numbers if num > threshold]\n    \n    print(f\"DEBUG: Filtered {len(numbers) - len(result)} elements, {len(result)} elements remaining\")\n    print(f\"DEBUG: Returning {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["[1, 5, 10, 15, 20]", "10"], "expected_output": "[15, 20]"}, {"input": ["[5, 5, 5, 10, 15]", "5"], "expected_output": "[10, 15]"}, {"input": ["[100, 200, 300]", "0"], "expected_output": "[100, 200, 300]"}], "failure": [{"input": ["[]", "5"], "expected_exception": "AssertionError", "expected_message_part": "Input list cannot be empty"}, {"input": ["'not a list'", "5"], "expected_exception": "AssertionError", "expected_message_part": "Expected list, got str"}, {"input": ["[1, 2, 3]", "'5'"], "expected_exception": "AssertionError", "expected_message_part": "Threshold must be a number, got str"}]}}
{"description": "文字列を指定された回数だけ繰り返す関数で、引数の型と値の範囲をチェックします。特に、文字列の検証と繰り返し回数の正の整数チェックが重要で、メモリ消費を考慮して上限も設定しています。", "keywords": ["string", "repeat", "multiplication", "validation", "assertion"], "code_before": "def repeat_string(text, times):\n    return text * times", "code_after": "def repeat_string(text, times):\n    print(f\"DEBUG: Starting repeat_string with text='{text}', times={times}\")\n    \n    # 入力検証\n    assert isinstance(text, str), f\"Expected string for text, got {type(text).__name__}\"\n    assert isinstance(times, int), f\"Expected integer for times, got {type(times).__name__}\"\n    assert times >= 0, f\"Times must be non-negative, got {times}\"\n    assert times <= 1000, f\"Times too large (max: 1000), got {times}\"\n    \n    print(f\"DEBUG: Repeating '{text}' {times} times\")\n    result = text * times\n    \n    print(f\"DEBUG: Result length: {len(result)} characters\")\n    print(f\"DEBUG: Returning repeated string (showing first 50 chars): '{result[:50]}{'...' if len(result) > 50 else ''}'\")    \n    \n    return result", "test_cases": {"success": [{"input": ["'hello'", "3"], "expected_output": "'hellohellohello'"}, {"input": ["'a'", "5"], "expected_output": "'aaaaa'"}, {"input": ["'test'", "0"], "expected_output": "''"}], "failure": [{"input": ["123", "3"], "expected_exception": "AssertionError", "expected_message_part": "Expected string for text, got int"}, {"input": ["'test'", "3.5"], "expected_exception": "AssertionError", "expected_message_part": "Expected integer for times, got float"}, {"input": ["'test'", "-1"], "expected_exception": "AssertionError", "expected_message_part": "Times must be non-negative"}, {"input": ["'test'", "1001"], "expected_exception": "AssertionError", "expected_message_part": "Times too large"}]}}
{"description": "辞書から安全に値を取得し、デフォルト値で変換する関数です。辞書、キー、デフォルト値の検証を行い、辞書にキーが存在しない場合や変換エラーが発生した場合の対応を含みます。また、変換関数を引数として受け取る柔軟な設計になっています。", "keywords": ["dictionary", "get", "default value", "type conversion", "error handling"], "code_before": "def safe_get_and_convert(data_dict, key, convert_func, default=None):\n    value = data_dict.get(key, default)\n    try:\n        return convert_func(value) if value is not None else default\n    except Exception:\n        return default", "code_after": "def safe_get_and_convert(data_dict, key, convert_func, default=None):\n    print(f\"DEBUG: Starting safe_get_and_convert for key='{key}'\")\n    \n    # 入力検証\n    assert isinstance(data_dict, dict), f\"Expected dictionary, got {type(data_dict).__name__}\"\n    assert isinstance(key, (str, int, float, bool, tuple)), f\"Key must be a valid dictionary key type, got {type(key).__name__}\"\n    assert callable(convert_func), f\"convert_func must be callable, got {type(convert_func).__name__}\"\n    \n    print(f\"DEBUG: Attempting to get value for key='{key}' from dictionary\")\n    value = data_dict.get(key, default)\n    print(f\"DEBUG: Retrieved value: {value} (type: {type(value).__name__})\")\n    \n    if value is None:\n        print(f\"DEBUG: Value is None, returning default: {default}\")\n        return default\n    \n    try:\n        result = convert_func(value)\n        print(f\"DEBUG: Successfully converted value to {type(result).__name__}: {result}\")\n        return result\n    except Exception as e:\n        print(f\"DEBUG: Conversion failed with error: {type(e).__name__}: {str(e)}\")\n        print(f\"DEBUG: Returning default: {default}\")\n        return default", "test_cases": {"success": [{"input": ["{\"age\": \"25\"}", "\"age\"", "int", "0"], "expected_output": "25"}, {"input": ["{\"price\": 19.99}", "\"price\"", "float", "0.0"], "expected_output": "19.99"}, {"input": ["{\"name\": \"John\"}", "\"address\"", "str", "\"Unknown\""], "expected_output": "\"Unknown\""}, {"input": ["{\"data\": \"invalid\"}", "\"data\"", "int", "0"], "expected_output": "0"}], "failure": [{"input": ["\"not_a_dict\"", "\"key\"", "int", "0"], "expected_exception": "AssertionError", "expected_message_part": "Expected dictionary, got str"}, {"input": ["{}", "None", "int", "0"], "expected_exception": "AssertionError", "expected_message_part": "Key must be a valid dictionary key type, got NoneType"}, {"input": ["{}", "\"key\"", "\"not_callable\"", "0"], "expected_exception": "AssertionError", "expected_message_part": "convert_func must be callable, got str"}]}}
{"description": "指定された範囲内のランダムな整数を複数生成する関数です。範囲の下限と上限、生成数の検証を行い、最終的に生成された整数リストを返します。また、重複を許可するかどうかのオプションも検証します。", "keywords": ["random", "range", "sample", "randint", "list generation"], "code_before": "import random\n\ndef generate_random_numbers(min_val, max_val, count, allow_duplicates=True):\n    if allow_duplicates:\n        return [random.randint(min_val, max_val) for _ in range(count)]\n    else:\n        if count > max_val - min_val + 1:\n            raise ValueError(\"Cannot generate unique numbers more than the range allows\")\n        return random.sample(range(min_val, max_val + 1), count)", "code_after": "import random\n\ndef generate_random_numbers(min_val, max_val, count, allow_duplicates=True):\n    print(f\"DEBUG: Starting generate_random_numbers with range [{min_val}, {max_val}], count={count}, allow_duplicates={allow_duplicates}\")\n    \n    # 入力検証\n    assert isinstance(min_val, int), f\"min_val must be an integer, got {type(min_val).__name__}\"\n    assert isinstance(max_val, int), f\"max_val must be an integer, got {type(max_val).__name__}\"\n    assert isinstance(count, int), f\"count must be an integer, got {type(count).__name__}\"\n    assert isinstance(allow_duplicates, bool), f\"allow_duplicates must be a boolean, got {type(allow_duplicates).__name__}\"\n    \n    assert min_val <= max_val, f\"min_val ({min_val}) must be less than or equal to max_val ({max_val})\"\n    assert count >= 0, f\"count must be non-negative, got {count}\"\n    \n    range_size = max_val - min_val + 1\n    if not allow_duplicates:\n        assert count <= range_size, f\"Cannot generate {count} unique numbers from a range of size {range_size}\"\n    \n    print(f\"DEBUG: Input validation passed, generating {count} {'unique ' if not allow_duplicates else ''}numbers\")\n    \n    result = []\n    if allow_duplicates:\n        result = [random.randint(min_val, max_val) for _ in range(count)]\n        print(f\"DEBUG: Generated {len(result)} numbers with possible duplicates\")\n    else:\n        result = random.sample(range(min_val, max_val + 1), count)\n        print(f\"DEBUG: Generated {len(result)} unique numbers\")\n    \n    print(f\"DEBUG: Returning result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["1", "10", "5", "True"], "expected_output": "# 結果はランダムなので正確な値ではなく長さと範囲をチェック\n# len(result) == 5 and all(1 <= x <= 10 for x in result)"}, {"input": ["1", "5", "5", "False"], "expected_output": "# 結果はランダムなので正確な値ではなく長さと範囲と重複なしをチェック\n# len(result) == 5 and all(1 <= x <= 5 for x in result) and len(set(result)) == 5"}, {"input": ["1", "100", "0", "True"], "expected_output": "[]"}], "failure": [{"input": ["'1'", "10", "5", "True"], "expected_exception": "AssertionError", "expected_message_part": "min_val must be an integer, got str"}, {"input": ["1", "10", "-5", "True"], "expected_exception": "AssertionError", "expected_message_part": "count must be non-negative"}, {"input": ["10", "1", "5", "True"], "expected_exception": "AssertionError", "expected_message_part": "min_val (10) must be less than or equal to max_val (1)"}, {"input": ["1", "5", "10", "False"], "expected_exception": "AssertionError", "expected_message_part": "Cannot generate 10 unique numbers from a range of size 5"}]}}
