{"title": "リスト内の要素を探索してフィルタリングする関数", "description": "この例では、リスト内の数値をフィルタリングする関数に対して、入力値のバリデーション（型チェック、空リストチェック）と閾値の妥当性チェックを行うアサーションを追加しています。また、関数の開始と終了、中間処理状態をf-stringを使ったデバッグプリントで可視化しています。こうしたアサーションとデバッグプリントは、リスト操作や条件フィルタリングを行う関数で特に有効です。", "keywords": ["list", "filter", "for", "if", "validation", "assertion"], "code_before": "def filter_numbers(numbers, threshold):\n    result = []\n    for num in numbers:\n        if num > threshold:\n            result.append(num)\n    return result", "code_after": "def filter_numbers(numbers, threshold):\n    print(f\"[DEBUG] filter_numbers() 開始: numbers={numbers}, threshold={threshold}\")\n    \n    # 入力値の検証\n    assert isinstance(numbers, list), \"numbers引数はリスト型でなければなりません\"\n    assert numbers, \"空のリストが渡されました\"\n    assert all(isinstance(num, (int, float)) for num in numbers), \"すべての要素は数値型である必要があります\"\n    assert isinstance(threshold, (int, float)), \"threshold引数は数値型でなければなりません\"\n    \n    result = []\n    print(f\"[DEBUG] フィルタリング処理開始: {len(numbers)}個の要素を処理します\")\n    \n    for i, num in enumerate(numbers):\n        print(f\"[DEBUG] 要素[{i}]={num}を処理中: 閾値{threshold}との比較\")\n        if num > threshold:\n            result.append(num)\n            print(f\"[DEBUG] 要素[{i}]={num}を結果に追加しました\")\n    \n    print(f\"[DEBUG] filter_numbers() 終了: 結果={result}（{len(result)}個の要素）\")\n    return result", "test_cases": {"success": [{"input": ["[1, 5, 10, 15, 20]", "10"], "expected_output": "[15, 20]"}, {"input": ["[10.5, 20.3, 5.7]", "10"], "expected_output": "[10.5, 20.3]"}], "failure": [{"input": ["'not a list'", "10"], "expected_exception": "AssertionError", "expected_message_part": "numbers引数はリスト型でなければなりません"}, {"input": ["[]", "10"], "expected_exception": "AssertionError", "expected_message_part": "空のリストが渡されました"}, {"input": ["[1, 2, '3']", "10"], "expected_exception": "AssertionError", "expected_message_part": "すべての要素は数値型である必要があります"}, {"input": ["[1, 2, 3]", "'10'"], "expected_exception": "AssertionError", "expected_message_part": "threshold引数は数値型でなければなりません"}]}}
{"title": "ファイルパスを検証して処理する関数", "description": "この例では、ファイルパスを引数に取り、そのパスが有効かどうかを検証して処理する関数に対して、パスの存在確認や権限チェックなどの厳密なアサーションを追加しています。また、関数の実行フローと重要なファイル操作前後の状態をデバッグプリントで追跡可能にしています。このパターンは、ファイル操作を行う関数や外部リソースへのアクセスを行う関数に適用すると効果的です。", "keywords": ["file", "path", "os.path", "validation", "permission", "exception"], "code_before": "import os\n\ndef process_file(file_path, mode='r'):\n    with open(file_path, mode) as f:\n        content = f.read()\n    return content", "code_after": "import os\n\ndef process_file(file_path, mode='r'):\n    print(f\"[DEBUG] process_file() 開始: file_path='{file_path}', mode='{mode}'\")\n    \n    # ファイルパスの検証\n    assert isinstance(file_path, str), \"file_pathは文字列でなければなりません\"\n    assert file_path.strip(), \"空のファイルパスが渡されました\"\n    assert os.path.exists(file_path), f\"指定されたパス '{file_path}' は存在しません\"\n    assert os.path.isfile(file_path), f\"指定されたパス '{file_path}' はファイルではありません\"\n    \n    # モードの検証\n    assert isinstance(mode, str), \"modeは文字列でなければなりません\"\n    assert mode in ['r', 'rb', 'w', 'wb', 'a', 'ab', 'r+', 'w+', 'a+'], f\"無効なファイルモード '{mode}' が指定されました\"\n    \n    # 読み取り権限の確認\n    if 'r' in mode or '+' in mode:\n        assert os.access(file_path, os.R_OK), f\"ファイル '{file_path}' の読み取り権限がありません\"\n    \n    # 書き込み権限の確認\n    if 'w' in mode or 'a' in mode or '+' in mode:\n        assert os.access(file_path, os.W_OK), f\"ファイル '{file_path}' の書き込み権限がありません\"\n    \n    print(f\"[DEBUG] ファイル '{file_path}' をモード '{mode}' で開きます\")\n    try:\n        with open(file_path, mode) as f:\n            print(f\"[DEBUG] ファイルを正常に開きました\")\n            content = f.read()\n            print(f\"[DEBUG] 読み込んだ内容のサイズ: {len(content)} バイト/文字\")\n    except Exception as e:\n        print(f\"[ERROR] ファイル操作中にエラーが発生しました: {str(e)}\")\n        raise\n    \n    print(f\"[DEBUG] process_file() 終了: 処理完了\")\n    return content", "test_cases": {"success": [{"input": ["'./test_file.txt'", "'r'"], "expected_output": "'This is a test file content'"}, {"input": ["'./binary_file.bin'", "'rb'"], "expected_output": "b'binary content'"}], "failure": [{"input": ["123", "'r'"], "expected_exception": "AssertionError", "expected_message_part": "file_pathは文字列でなければなりません"}, {"input": ["''", "'r'"], "expected_exception": "AssertionError", "expected_message_part": "空のファイルパスが渡されました"}, {"input": ["'./non_existent_file.txt'", "'r'"], "expected_exception": "AssertionError", "expected_message_part": "指定されたパスは存在しません"}, {"input": ["'./existing_directory'", "'r'"], "expected_exception": "AssertionError", "expected_message_part": "指定されたパスはファイルではありません"}, {"input": ["'./test_file.txt'", "'x'"], "expected_exception": "AssertionError", "expected_message_part": "無効なファイルモード"}, {"input": ["'./readonly_file.txt'", "'w'"], "expected_exception": "AssertionError", "expected_message_part": "書き込み権限がありません"}]}}
{"title": "日付・時刻の検証と変換を行う関数", "description": "この例は、文字列形式の日付・時刻データを検証して標準形式に変換する関数をリファクタリングしたものです。アサーションにより入力パラメータの型・形式チェックを行い、デバッグプリントにより変換プロセスの各ステップを追跡します。これは日付・時刻データを扱う関数に適用できるパターンで、特に外部入力データの検証が必要な場合に有効です。", "keywords": ["datetime", "strptime", "date validation", "string formatting", "type checking"], "code_before": "def convert_date_format(date_string, input_format=\"%Y-%m-%d\", output_format=\"%d/%m/%Y\"):\n    from datetime import datetime\n    \n    try:\n        date_obj = datetime.strptime(date_string, input_format)\n        formatted_date = date_obj.strftime(output_format)\n        return formatted_date\n    except ValueError:\n        return None", "code_after": "def convert_date_format(date_string, input_format=\"%Y-%m-%d\", output_format=\"%d/%m/%Y\"):\n    from datetime import datetime\n    \n    print(f\"Starting date conversion: date_string='{date_string}', input_format='{input_format}', output_format='{output_format}'\")\n    \n    # アサーション: 入力パラメータの型チェック\n    assert isinstance(date_string, str), f\"date_string must be a string, got {type(date_string).__name__}\"\n    assert isinstance(input_format, str), f\"input_format must be a string, got {type(input_format).__name__}\"\n    assert isinstance(output_format, str), f\"output_format must be a string, got {type(output_format).__name__}\"\n    \n    # アサーション: 入力文字列が空でないことを確認\n    assert date_string.strip(), \"date_string cannot be empty or whitespace only\"\n    \n    # アサーション: フォーマット文字列が有効であることを確認\n    assert '%' in input_format, \"input_format must contain at least one format specifier (%) character\"\n    assert '%' in output_format, \"output_format must contain at least one format specifier (%) character\"\n    \n    print(f\"All assertions passed, proceeding with conversion\")\n    \n    try:\n        print(f\"Attempting to parse '{date_string}' with format '{input_format}'\")\n        date_obj = datetime.strptime(date_string, input_format)\n        print(f\"Successfully parsed to datetime object: {date_obj}\")\n        \n        formatted_date = date_obj.strftime(output_format)\n        print(f\"Successfully formatted to output format: '{formatted_date}'\")\n        return formatted_date\n    except ValueError as e:\n        print(f\"ERROR: Date conversion failed - {str(e)}\")\n        return None", "test_cases": {"success": [{"input": ["'2023-10-15'"], "expected_output": "'15/10/2023'"}, {"input": ["'2023-10-15'", "'%Y-%m-%d'", "'%Y年%m月%d日'"], "expected_output": "'2023年10月15日'"}, {"input": ["'10/15/2023'", "'%m/%d/%Y'", "'%Y-%m-%d'"], "expected_output": "'2023-10-15'"}], "failure": [{"input": [123], "expected_exception": "AssertionError", "expected_message_part": "date_string must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "date_string cannot be empty"}, {"input": ["'2023-10-15'", "'no-format-specifier'"], "expected_exception": "AssertionError", "expected_message_part": "input_format must contain at least one format specifier"}, {"input": ["'2023-10-15'", "'%Y-%m-%d'", "'no-format-specifier'"], "expected_exception": "AssertionError", "expected_message_part": "output_format must contain at least one format specifier"}]}}
{"title": "数値範囲の正規化・スケーリングを行う関数", "description": "この例は、入力された数値を指定範囲から別の範囲へスケーリング（正規化）する関数です。アサーションにより入力値や範囲パラメータの妥当性を厳密に検証し、デバッグプリントによりスケーリング計算の各ステップを追跡します。このパターンは、データ前処理、機械学習の特徴量スケーリング、グラフィック処理などで数値変換を行う場合に特に有効です。", "keywords": ["normalization", "scaling", "range", "numbers", "min-max", "linear transformation"], "code_before": "def normalize_value(value, from_min, from_max, to_min=0, to_max=1):\n    ratio = (value - from_min) / (from_max - from_min)\n    normalized = to_min + ratio * (to_max - to_min)\n    return normalized", "code_after": "def normalize_value(value, from_min, from_max, to_min=0, to_max=1):\n    print(f\"Starting normalization: value={value}, from_range=[{from_min}, {from_max}], to_range=[{to_min}, {to_max}]\")\n    \n    # アサーション: 入力値の型チェック\n    assert isinstance(value, (int, float)), f\"Value must be a number, got {type(value).__name__}\"\n    assert isinstance(from_min, (int, float)), f\"from_min must be a number, got {type(from_min).__name__}\"\n    assert isinstance(from_max, (int, float)), f\"from_max must be a number, got {type(from_max).__name__}\"\n    assert isinstance(to_min, (int, float)), f\"to_min must be a number, got {type(to_min).__name__}\"\n    assert isinstance(to_max, (int, float)), f\"to_max must be a number, got {type(to_max).__name__}\"\n    \n    # アサーション: 範囲の妥当性チェック\n    assert from_min != from_max, \"Input range cannot have zero width (from_min == from_max)\"\n    assert to_min != to_max, \"Output range cannot have zero width (to_min == to_max)\"\n    \n    # アサーション: 入力値が範囲内にあることを確認\n    assert from_min <= value <= from_max or from_max <= value <= from_min, \\\n        f\"Value {value} is outside the input range [{from_min}, {from_max}]\"\n    \n    print(f\"All assertions passed, proceeding with normalization calculation\")\n    \n    # 計算ステップの詳細をデバッグ出力\n    print(f\"Step 1: Calculate ratio = (value - from_min) / (from_max - from_min)\")\n    ratio = (value - from_min) / (from_max - from_min)\n    print(f\"       ratio = ({value} - {from_min}) / ({from_max} - {from_min}) = {ratio}\")\n    \n    print(f\"Step 2: Calculate normalized = to_min + ratio * (to_max - to_min)\")\n    normalized = to_min + ratio * (to_max - to_min)\n    print(f\"       normalized = {to_min} + {ratio} * ({to_max} - {to_min}) = {normalized}\")\n    \n    print(f\"Normalization complete: {value} -> {normalized}\")\n    return normalized", "test_cases": {"success": [{"input": ["50", "0", "100"], "expected_output": "0.5"}, {"input": ["50", "0", "100", "0", "10"], "expected_output": "5.0"}, {"input": ["0", "-10", "10", "-1", "1"], "expected_output": "0.0"}, {"input": ["75", "100", "0", "0", "1"], "expected_output": "0.25"}], "failure": [{"input": ["'50'", "0", "100"], "expected_exception": "AssertionError", "expected_message_part": "Value must be a number"}, {"input": ["50", "0", "0"], "expected_exception": "AssertionError", "expected_message_part": "Input range cannot have zero width"}, {"input": ["50", "0", "100", "5", "5"], "expected_exception": "AssertionError", "expected_message_part": "Output range cannot have zero width"}, {"input": ["150", "0", "100"], "expected_exception": "AssertionError", "expected_message_part": "Value 150 is outside the input range"}]}}
{"title": "XMLパーサー関数のバリデーションとデバッグ強化", "description": "XMLデータの解析処理において、入力検証とデバッグを強化するアサーションとプリントパターンです。XMLの構文解析は複雑なため、入力の型チェック、非空チェック、整形式チェックなどを厳密に行い、処理の各段階でデバッグ情報を出力することで、問題解決を容易にします。", "keywords": ["xml", "parsing", "ElementTree", "validation", "exception handling"], "code_before": "import xml.etree.ElementTree as ET\n\ndef parse_xml_and_get_value(xml_string, xpath):\n    root = ET.fromstring(xml_string)\n    elements = root.findall(xpath)\n    if elements:\n        return elements[0].text\n    return None", "code_after": "import xml.etree.ElementTree as ET\nimport logging\n\ndef parse_xml_and_get_value(xml_string, xpath):\n    print(f\"[DEBUG] Starting XML parsing with xpath: {xpath}\")\n    \n    # アサーション: 入力パラメータの検証\n    assert isinstance(xml_string, str), f\"xml_string must be a string, got {type(xml_string)}\"\n    assert xml_string.strip(), \"xml_string cannot be empty or whitespace only\"\n    assert isinstance(xpath, str), f\"xpath must be a string, got {type(xpath)}\"\n    assert xpath.strip(), \"xpath cannot be empty or whitespace only\"\n    \n    try:\n        print(f\"[DEBUG] Attempting to parse XML string of length: {len(xml_string)}\")\n        root = ET.fromstring(xml_string)\n        print(f\"[DEBUG] XML parsing successful. Root tag: {root.tag}\")\n        \n        print(f\"[DEBUG] Searching for elements with xpath: {xpath}\")\n        elements = root.findall(xpath)\n        print(f\"[DEBUG] Found {len(elements)} elements matching xpath\")\n        \n        if elements:\n            result = elements[0].text\n            print(f\"[DEBUG] Returning value: {result}\")\n            return result\n        else:\n            print(f\"[DEBUG] No elements found for xpath: {xpath}\")\n            return None\n    except ET.ParseError as e:\n        print(f\"[ERROR] XML parsing failed: {e}\")\n        # アサーション: XMLの解析エラーをチェック\n        assert False, f\"Invalid XML format: {e}\"\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error during XML processing: {e}\")\n        raise", "test_cases": {"success": [{"input": ["'<root><user><name>John</name><age>30</age></user></root>'", "'./user/name'"], "expected_output": "'John'"}, {"input": ["'<root><user><name>John</name><age>30</age></user></root>'", "'./user/age'"], "expected_output": "'30'"}, {"input": ["'<root><user><name>John</name><age>30</age></user></root>'", "'./user/email'"], "expected_output": "None"}], "failure": [{"input": [123, "'./user/name'"], "expected_exception": "AssertionError", "expected_message_part": "xml_string must be a string"}, {"input": ["''", "'./user/name'"], "expected_exception": "AssertionError", "expected_message_part": "xml_string cannot be empty"}, {"input": ["'<root><user><name>John</name>'", "'./user/name'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid XML format"}, {"input": ["'<root><user><name>John</name></user></root>'", 123], "expected_exception": "AssertionError", "expected_message_part": "xpath must be a string"}, {"input": ["'<root><user><name>John</name></user></root>'", "''"], "expected_exception": "AssertionError", "expected_message_part": "xpath cannot be empty"}]}}
{"title": "データベース接続とクエリ実行の安全な関数", "description": "データベース操作において、接続パラメータの検証とSQLインジェクション防止のためのアサーション、また接続状態やクエリ実行過程を監視するためのデバッグプリントを挿入します。このパターンは特にデータベースとの対話が発生する関数で重要で、接続の成功/失敗、クエリの実行状況、結果セットのサイズなどを追跡します。", "keywords": ["database", "SQL", "connection", "query", "cursor", "execute", "parameters", "sqlite"], "code_before": "import sqlite3\n\ndef execute_query(db_path, query, params=None):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    \n    if params:\n        cursor.execute(query, params)\n    else:\n        cursor.execute(query)\n        \n    results = cursor.fetchall()\n    conn.close()\n    return results", "code_after": "import sqlite3\nimport os.path\nimport re\n\ndef execute_query(db_path, query, params=None):\n    print(f\"[DEBUG] Starting database query execution\")\n    print(f\"[DEBUG] Database path: {db_path}\")\n    print(f\"[DEBUG] Query: {query}\")\n    print(f\"[DEBUG] Parameters: {params}\")\n    \n    # アサーション: データベースパスの検証\n    assert isinstance(db_path, str), f\"Database path must be a string, got {type(db_path)}\"\n    assert os.path.exists(db_path) or db_path == ':memory:', f\"Database file does not exist: {db_path}\"\n    \n    # アサーション: クエリの検証\n    assert isinstance(query, str), f\"Query must be a string, got {type(query)}\"\n    assert query.strip(), \"Query cannot be empty\"\n    \n    # アサーション: パラメータの検証\n    if params is not None:\n        assert isinstance(params, (list, tuple, dict)), f\"Parameters must be list, tuple or dict, got {type(params)}\"\n    \n    # SQLインジェクションの簡易チェック (実際のアプリケーションではより堅牢な方法を使用)\n    if params is None:\n        risky_patterns = [\"--\", \";\", \"DROP\", \"DELETE\", \"UPDATE\", \"INSERT\"]\n        for pattern in risky_patterns:\n            assert not re.search(pattern, query, re.IGNORECASE), f\"Potentially unsafe query without parameters: {query}\"\n    \n    try:\n        print(f\"[DEBUG] Connecting to database: {db_path}\")\n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        print(f\"[DEBUG] Connection established successfully\")\n        \n        try:\n            if params:\n                print(f\"[DEBUG] Executing parameterized query\")\n                cursor.execute(query, params)\n            else:\n                print(f\"[DEBUG] Executing direct query\")\n                cursor.execute(query)\n                \n            print(f\"[DEBUG] Query executed successfully\")\n            results = cursor.fetchall()\n            print(f\"[DEBUG] Fetched {len(results)} rows from database\")\n            return results\n        except sqlite3.Error as e:\n            print(f\"[ERROR] Query execution failed: {e}\")\n            raise\n        finally:\n            print(f\"[DEBUG] Closing database connection\")\n            conn.close()\n    except sqlite3.Error as e:\n        print(f\"[ERROR] Database connection failed: {e}\")\n        raise", "test_cases": {"success": [{"input": ["':memory:'", "'SELECT 1'"], "expected_output": "'[(1,)]'"}, {"input": ["':memory:'", "'SELECT ? AS test'", "'[\"value\"]'"], "expected_output": "'[(\"value\",)]'"}, {"input": ["':memory:'", "'SELECT * FROM sqlite_master'"], "expected_output": "'[]'"}], "failure": [{"input": [123, "'SELECT 1'"], "expected_exception": "AssertionError", "expected_message_part": "Database path must be a string"}, {"input": ["'non_existent_db.db'", "'SELECT 1'"], "expected_exception": "AssertionError", "expected_message_part": "Database file does not exist"}, {"input": ["':memory:'", 123], "expected_exception": "AssertionError", "expected_message_part": "Query must be a string"}, {"input": ["':memory:'", "''"], "expected_exception": "AssertionError", "expected_message_part": "Query cannot be empty"}, {"input": ["':memory:'", "'SELECT 1'", "'not_a_sequence_or_dict'"], "expected_exception": "AssertionError", "expected_message_part": "Parameters must be list, tuple or dict"}, {"input": ["':memory:'", "'SELECT 1; DROP TABLE users'"], "expected_exception": "AssertionError", "expected_message_part": "Potentially unsafe query without parameters"}]}}
{"title": "画像処理関数の検証とデバッグ強化", "description": "画像処理関数において、入力画像の次元、型、値範囲を厳密に検証し、処理の各段階でデバッグ情報を出力するパターンです。NumPyとPILを使った画像処理では、処理前の画像の形状やデータ型の確認が特に重要で、メモリエラーや予期せぬ変換エラーを防ぐために適切なアサーションとデバッグプリントを挿入します。", "keywords": ["image processing", "numpy", "PIL", "validation", "shape", "dtype", "dimensions"], "code_before": "import numpy as np\nfrom PIL import Image\n\ndef apply_gaussian_blur(image_array, kernel_size=5, sigma=1.0):\n    from scipy.ndimage import gaussian_filter\n    \n    blurred = gaussian_filter(image_array, sigma=sigma, order=0)\n    return blurred", "code_after": "import numpy as np\nfrom PIL import Image\nimport sys\n\ndef apply_gaussian_blur(image_array, kernel_size=5, sigma=1.0):\n    from scipy.ndimage import gaussian_filter\n    \n    print(f\"[DEBUG] Starting gaussian blur with kernel_size={kernel_size}, sigma={sigma}\")\n    \n    # アサーション: 入力画像の検証\n    assert isinstance(image_array, np.ndarray), f\"Input must be numpy array, got {type(image_array)}\"\n    assert 2 <= image_array.ndim <= 3, f\"Image must be 2D or 3D array, got {image_array.ndim}D\"\n    \n    # アサーション: カーネルサイズの検証\n    assert isinstance(kernel_size, int), f\"kernel_size must be an integer, got {type(kernel_size)}\"\n    assert kernel_size > 0 and kernel_size % 2 == 1, f\"kernel_size must be positive odd number, got {kernel_size}\"\n    \n    # アサーション: シグマ値の検証\n    assert isinstance(sigma, (int, float)), f\"sigma must be a number, got {type(sigma)}\"\n    assert sigma > 0, f\"sigma must be positive, got {sigma}\"\n    \n    # 画像の基本情報をデバッグ出力\n    print(f\"[DEBUG] Input image shape: {image_array.shape}\")\n    print(f\"[DEBUG] Input image dtype: {image_array.dtype}\")\n    print(f\"[DEBUG] Input image min/max values: {image_array.min()}/{image_array.max()}\")\n    \n    # メモリ使用量の概算をデバッグ出力\n    image_size_mb = image_array.nbytes / (1024 * 1024)\n    print(f\"[DEBUG] Input image memory usage: {image_size_mb:.2f} MB\")\n    \n    try:\n        print(f\"[DEBUG] Applying gaussian filter...\")\n        start_time = np.datetime64('now')\n        \n        blurred = gaussian_filter(image_array, sigma=sigma, order=0)\n        \n        end_time = np.datetime64('now')\n        duration = (end_time - start_time) / np.timedelta64(1, 'ms')\n        print(f\"[DEBUG] Gaussian filter applied in {duration:.2f} ms\")\n        \n        # 結果の基本情報をデバッグ出力\n        print(f\"[DEBUG] Output image shape: {blurred.shape}\")\n        print(f\"[DEBUG] Output image dtype: {blurred.dtype}\")\n        print(f\"[DEBUG] Output image min/max values: {blurred.min()}/{blurred.max()}\")\n        \n        # アサーション: 出力画像の検証\n        assert blurred.shape == image_array.shape, f\"Output shape {blurred.shape} doesn't match input shape {image_array.shape}\"\n        assert blurred.dtype == image_array.dtype, f\"Output dtype {blurred.dtype} doesn't match input dtype {image_array.dtype}\"\n        \n        return blurred\n    except Exception as e:\n        print(f\"[ERROR] Error during gaussian blur: {e}\")\n        raise", "test_cases": {"success": [{"input": ["np.zeros((100, 100), dtype=np.uint8)", "5", "1.0"], "expected_output": "'array with shape (100, 100) of zeros'"}, {"input": ["np.zeros((100, 100, 3), dtype=np.uint8)", "3", "0.5"], "expected_output": "'array with shape (100, 100, 3) of zeros'"}, {"input": ["np.ones((50, 50), dtype=np.float32)", "7", "2.0"], "expected_output": "'array with shape (50, 50) of blurred ones'"}], "failure": [{"input": ["'not_an_array'", "5", "1.0"], "expected_exception": "AssertionError", "expected_message_part": "Input must be numpy array"}, {"input": ["np.zeros((10,), dtype=np.uint8)", "5", "1.0"], "expected_exception": "AssertionError", "expected_message_part": "Image must be 2D or 3D array"}, {"input": ["np.zeros((100, 100), dtype=np.uint8)", "4", "1.0"], "expected_exception": "AssertionError", "expected_message_part": "kernel_size must be positive odd number"}, {"input": ["np.zeros((100, 100), dtype=np.uint8)", "5", "'invalid'"], "expected_exception": "AssertionError", "expected_message_part": "sigma must be a number"}, {"input": ["np.zeros((100, 100), dtype=np.uint8)", "5", "-1.0"], "expected_exception": "AssertionError", "expected_message_part": "sigma must be positive"}]}}
{"title": "Web APIリクエストの検証と結果処理", "description": "HTTP APIリクエストを行う関数に対して、入力パラメータの検証とリクエスト処理の各段階でデバッグプリントを挿入しています。URLの形式検証、HTTPメソッドの検証、タイムアウト値の検証など複数のアサーションを追加し、リクエスト前後の状態やエラー処理の過程を追跡できるようにしています。", "keywords": ["requests", "http", "api", "get", "post", "url", "timeout", "exception"], "code_before": "import requests\n\ndef make_api_request(url, method='GET', params=None, headers=None, timeout=30):\n    \"\"\"指定されたURLにHTTPリクエストを送信する関数\"\"\"\n    methods = {'GET': requests.get, 'POST': requests.post, 'PUT': requests.put, 'DELETE': requests.delete}\n    request_func = methods.get(method.upper())\n    \n    try:\n        response = request_func(url, params=params, headers=headers, timeout=timeout)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        return {'error': str(e)}\n", "code_after": "import requests\nimport re\n\ndef make_api_request(url, method='GET', params=None, headers=None, timeout=30):\n    \"\"\"指定されたURLにHTTPリクエストを送信する関数\"\"\"\n    print(f\"API Request initiated: url={url}, method={method}\")\n    \n    # URLの形式を検証\n    assert isinstance(url, str), f\"URL must be a string, got {type(url)}\"\n    url_pattern = r'^https?://[\\w.-]+(:\\d+)?(/[\\w.-]*)*/?$'\n    assert re.match(url_pattern, url), f\"Invalid URL format: {url}\"\n    \n    # HTTPメソッドの検証\n    valid_methods = {'GET', 'POST', 'PUT', 'DELETE'}\n    assert method.upper() in valid_methods, f\"Method must be one of {valid_methods}, got {method}\"\n    \n    # タイムアウト値の検証\n    assert isinstance(timeout, (int, float)), f\"Timeout must be a number, got {type(timeout)}\"\n    assert timeout > 0, f\"Timeout must be positive, got {timeout}\"\n    \n    methods = {'GET': requests.get, 'POST': requests.post, 'PUT': requests.put, 'DELETE': requests.delete}\n    request_func = methods.get(method.upper())\n    \n    print(f\"Request parameters: params={params}, headers={headers}, timeout={timeout}\")\n    \n    try:\n        print(f\"Sending {method} request to {url}...\")\n        response = request_func(url, params=params, headers=headers, timeout=timeout)\n        print(f\"Response received: status_code={response.status_code}\")\n        \n        response.raise_for_status()\n        data = response.json()\n        print(f\"Response parsed successfully: {type(data)}\")\n        return data\n    except requests.exceptions.Timeout as e:\n        print(f\"Request timed out after {timeout} seconds: {e}\")\n        return {'error': f'Request timed out: {str(e)}'}\n    except requests.exceptions.HTTPError as e:\n        print(f\"HTTP error occurred: {e}, status_code={e.response.status_code}\")\n        return {'error': f'HTTP error: {str(e)}'}\n    except requests.exceptions.ConnectionError as e:\n        print(f\"Connection error occurred: {e}\")\n        return {'error': f'Connection error: {str(e)}'}\n    except requests.exceptions.RequestException as e:\n        print(f\"Request exception occurred: {e}\")\n        return {'error': f'Request failed: {str(e)}'}\n    except ValueError as e:\n        print(f\"Failed to parse response as JSON: {e}\")\n        return {'error': f'Invalid JSON response: {str(e)}'}\n", "test_cases": {"success": [{"input": ["'https://jsonplaceholder.typicode.com/posts/1'", "'GET'", "None", "None", "30"], "expected_output": "{'userId': 1, 'id': 1, 'title': 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit', 'body': 'quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto'}"}, {"input": ["'https://jsonplaceholder.typicode.com/posts'", "'POST'", "{'title': 'foo', 'body': 'bar', 'userId': 1}", "{'Content-Type': 'application/json'}", "15"], "expected_output": "{'id': 101, 'title': 'foo', 'body': 'bar', 'userId': 1}"}], "failure": [{"input": ["123", "'GET'", "None", "None", "30"], "expected_exception": "AssertionError", "expected_message_part": "URL must be a string"}, {"input": ["'invalid-url'", "'GET'", "None", "None", "30"], "expected_exception": "AssertionError", "expected_message_part": "Invalid URL format"}, {"input": ["'https://example.com'", "'INVALID'", "None", "None", "30"], "expected_exception": "AssertionError", "expected_message_part": "Method must be one of"}, {"input": ["'https://example.com'", "'GET'", "None", "None", "-5"], "expected_exception": "AssertionError", "expected_message_part": "Timeout must be positive"}]}}
{"title": "ユーザー認証情報の検証と暗号化", "description": "ユーザー認証情報を検証し暗号化する関数に対して、入力データの型・形式のアサーションと処理の各ステップでのデバッグプリントを追加しています。パスワードの複雑さの検証、ユーザー名のフォーマット検証、そして暗号化処理の追跡を行っています。特に、セキュリティ関連の関数では入力検証が重要であり、処理の透明性を確保するためのデバッグ情報が有用です。", "keywords": ["authentication", "encryption", "password", "hash", "bcrypt", "validation", "security"], "code_before": "import bcrypt\nimport re\n\ndef validate_and_encrypt_password(username, password):\n    \"\"\"ユーザー名とパスワードを検証し、パスワードを暗号化する\"\"\"\n    # ユーザー名が有効かチェック\n    if not 3 <= len(username) <= 20:\n        return None, \"Username must be between 3 and 20 characters\"\n    \n    # パスワードの強度をチェック\n    if len(password) < 8:\n        return None, \"Password must be at least 8 characters\"\n    \n    # パスワードを暗号化\n    salt = bcrypt.gensalt()\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\n    \n    return hashed, None\n", "code_after": "import bcrypt\nimport re\n\ndef validate_and_encrypt_password(username, password):\n    \"\"\"ユーザー名とパスワードを検証し、パスワードを暗号化する\"\"\"\n    print(f\"Starting validation for username: {username}\")\n    \n    # 入力パラメータの型チェック\n    assert isinstance(username, str), f\"Username must be a string, got {type(username)}\"\n    assert isinstance(password, str), f\"Password must be a string, got {type(password)}\"\n    \n    # ユーザー名が有効かチェック\n    assert 3 <= len(username) <= 20, f\"Username length must be between 3 and 20 characters, got {len(username)}\"\n    \n    # ユーザー名の文字列パターン検証\n    username_pattern = r'^[a-zA-Z0-9_]+$'\n    assert re.match(username_pattern, username), f\"Username contains invalid characters: {username}\"\n    \n    print(f\"Username '{username}' passed validation\")\n    \n    # パスワードの強度をチェック\n    assert len(password) >= 8, f\"Password must be at least 8 characters, got {len(password)}\"\n    \n    # パスワードの複雑さチェック\n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    has_special = any(not c.isalnum() for c in password)\n    \n    print(f\"Password complexity: uppercase={has_upper}, lowercase={has_lower}, digits={has_digit}, special_chars={has_special}\")\n    \n    assert has_upper, \"Password must contain at least one uppercase letter\"\n    assert has_lower, \"Password must contain at least one lowercase letter\"\n    assert has_digit, \"Password must contain at least one digit\"\n    assert has_special, \"Password must contain at least one special character\"\n    \n    print(\"Password passed complexity requirements\")\n    \n    # パスワードを暗号化\n    try:\n        print(\"Generating salt for password encryption...\")\n        salt = bcrypt.gensalt()\n        print(f\"Salt generated: {salt}\")\n        \n        print(\"Hashing password...\")\n        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\n        print(f\"Password hashed successfully, hash length: {len(hashed)}\")\n        \n        return hashed, None\n    except Exception as e:\n        print(f\"Error during password encryption: {str(e)}\")\n        return None, f\"Encryption error: {str(e)}\"\n", "test_cases": {"success": [{"input": ["'user123'", "'P@ssw0rd!'"], "expected_output": "('$2b$12$...', None)"}, {"input": ["'admin_user'", "'Secure123#'"], "expected_output": "('$2b$12$...', None)"}], "failure": [{"input": ["123", "'Password123!'"], "expected_exception": "AssertionError", "expected_message_part": "Username must be a string"}, {"input": ["'ab'", "'Password123!'"], "expected_exception": "AssertionError", "expected_message_part": "Username length must be between 3 and 20"}, {"input": ["'user@name'", "'Password123!'"], "expected_exception": "AssertionError", "expected_message_part": "Username contains invalid characters"}, {"input": ["'username'", "'short'"], "expected_exception": "AssertionError", "expected_message_part": "Password must be at least 8 characters"}, {"input": ["'username'", "'password123'"], "expected_exception": "AssertionError", "expected_message_part": "Password must contain at least one uppercase letter"}, {"input": ["'username'", "'PASSWORD123'"], "expected_exception": "AssertionError", "expected_message_part": "Password must contain at least one lowercase letter"}, {"input": ["'username'", "'Password!@#'"], "expected_exception": "AssertionError", "expected_message_part": "Password must contain at least one digit"}, {"input": ["'username'", "'Password123'"], "expected_exception": "AssertionError", "expected_message_part": "Password must contain at least one special character"}]}}
{"title": "メールアドレスの検証と正規化関数", "description": "メールアドレスを検証し正規化する関数にアサーションとデバッグプリントを追加しました。アサーションは入力値の型チェックや基本的なメールアドレスのパターン検証を行います。デバッグプリントは処理の各ステップ（関数開始、正規化前後の値、検証結果）を追跡できるようにしています。特に正規表現を使った検証プロセスが追跡しやすくなっています。", "keywords": ["email", "validation", "normalization", "regex", "string", "lower", "strip"], "code_before": "import re\n\ndef validate_and_normalize_email(email):\n    # 小文字に変換して前後の空白を削除\n    email = email.lower().strip()\n    \n    # メールアドレスの基本的な形式を検証\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    if not re.match(pattern, email):\n        return None\n    \n    return email", "code_after": "import re\n\ndef validate_and_normalize_email(email):\n    print(f\"Starting email validation for: {email}\")\n    \n    # 入力値の検証\n    assert email is not None, \"Email cannot be None\"\n    assert isinstance(email, str), f\"Email must be a string, got {type(email)}\"\n    assert len(email) > 0, \"Email cannot be empty\"\n    \n    # 小文字に変換して前後の空白を削除\n    original_email = email\n    email = email.lower().strip()\n    print(f\"Normalized email: '{original_email}' -> '{email}'\")\n    \n    # メールアドレスの基本的な形式を検証\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    print(f\"Validating against pattern: {pattern}\")\n    \n    match_result = re.match(pattern, email)\n    print(f\"Pattern match result: {match_result is not None}\")\n    \n    if not match_result:\n        print(f\"Validation failed for email: {email}\")\n        return None\n    \n    print(f\"Email validation successful: {email}\")\n    return email", "test_cases": {"success": [{"input": ["'user@example.com'"], "expected_output": "'user@example.com'"}, {"input": ["'  User@EXAMPLE.com  '"], "expected_output": "'user@example.com'"}, {"input": ["'user.name+tag@example-site.co.uk'"], "expected_output": "'user.name+tag@example-site.co.uk'"}], "failure": [{"input": [null], "expected_exception": "AssertionError", "expected_message_part": "Email cannot be None"}, {"input": [123], "expected_exception": "AssertionError", "expected_message_part": "Email must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "Email cannot be empty"}]}}
{"title": "温度単位変換関数のバリデーションとデバッグ", "description": "温度単位変換（摂氏・華氏・ケルビン）を行う関数に対してアサーションとデバッグプリントを追加しました。アサーションは入力値の型、単位指定の妥当性、物理的に不可能な温度（絶対零度未満）などをチェックします。デバッグプリントは変換プロセスの各ステップとその結果を追跡できるようにしています。特に単位間の変換計算が明示的に表示されるため、計算ミスのデバッグに役立ちます。", "keywords": ["temperature", "conversion", "float", "celsius", "fahrenheit", "kelvin", "validation", "physics"], "code_before": "def convert_temperature(value, from_unit, to_unit):\n    units = ['celsius', 'fahrenheit', 'kelvin']\n    \n    # まず摂氏に変換\n    if from_unit == 'celsius':\n        celsius = value\n    elif from_unit == 'fahrenheit':\n        celsius = (value - 32) * 5/9\n    elif from_unit == 'kelvin':\n        celsius = value - 273.15\n    \n    # 目標単位に変換\n    if to_unit == 'celsius':\n        result = celsius\n    elif to_unit == 'fahrenheit':\n        result = celsius * 9/5 + 32\n    elif to_unit == 'kelvin':\n        result = celsius + 273.15\n    \n    return round(result, 2)", "code_after": "def convert_temperature(value, from_unit, to_unit):\n    print(f\"Starting temperature conversion: {value} {from_unit} to {to_unit}\")\n    \n    # 入力値の検証\n    assert isinstance(value, (int, float)), f\"Temperature value must be a number, got {type(value)}\"\n    assert isinstance(from_unit, str), f\"From unit must be a string, got {type(from_unit)}\"\n    assert isinstance(to_unit, str), f\"To unit must be a string, got {type(to_unit)}\"\n    \n    units = ['celsius', 'fahrenheit', 'kelvin']\n    assert from_unit.lower() in units, f\"From unit must be one of {units}, got '{from_unit}'\"\n    assert to_unit.lower() in units, f\"To unit must be one of {units}, got '{to_unit}'\"\n    \n    # 単位を小文字に正規化\n    from_unit = from_unit.lower()\n    to_unit = to_unit.lower()\n    print(f\"Normalized units: from '{from_unit}' to '{to_unit}'\")\n    \n    # まず摂氏に変換\n    if from_unit == 'celsius':\n        celsius = value\n        print(f\"Already in celsius: {celsius}°C\")\n    elif from_unit == 'fahrenheit':\n        celsius = (value - 32) * 5/9\n        print(f\"Converted from fahrenheit: {value}°F -> {celsius}°C (using (F-32)*5/9)\")\n    elif from_unit == 'kelvin':\n        celsius = value - 273.15\n        print(f\"Converted from kelvin: {value}K -> {celsius}°C (using K-273.15)\")\n    \n    # 絶対零度チェック\n    assert celsius >= -273.15, f\"Temperature {celsius}°C is below absolute zero (-273.15°C)\"\n    print(f\"Temperature is physically possible: {celsius}°C >= -273.15°C\")\n    \n    # 目標単位に変換\n    if to_unit == 'celsius':\n        result = celsius\n        print(f\"Final result in celsius: {result}°C\")\n    elif to_unit == 'fahrenheit':\n        result = celsius * 9/5 + 32\n        print(f\"Converted to fahrenheit: {celsius}°C -> {result}°F (using C*9/5+32)\")\n    elif to_unit == 'kelvin':\n        result = celsius + 273.15\n        print(f\"Converted to kelvin: {celsius}°C -> {result}K (using C+273.15)\")\n    \n    rounded_result = round(result, 2)\n    print(f\"Rounded result: {result} -> {rounded_result}\")\n    \n    return rounded_result", "test_cases": {"success": [{"input": [100, "'celsius'", "'fahrenheit'"], "expected_output": "212.0"}, {"input": [32, "'fahrenheit'", "'celsius'"], "expected_output": "0.0"}, {"input": [0, "'celsius'", "'kelvin'"], "expected_output": "273.15"}, {"input": [300, "'kelvin'", "'celsius'"], "expected_output": "26.85"}], "failure": [{"input": ["'twenty'", "'celsius'", "'fahrenheit'"], "expected_exception": "AssertionError", "expected_message_part": "Temperature value must be a number"}, {"input": [100, 123, "'fahrenheit'"], "expected_exception": "AssertionError", "expected_message_part": "From unit must be a string"}, {"input": [100, "'celsius'", "'rankine'"], "expected_exception": "AssertionError", "expected_message_part": "To unit must be one of"}, {"input": [-300, "'celsius'", "'kelvin'"], "expected_exception": "AssertionError", "expected_message_part": "below absolute zero"}]}}
{"title": "キャッシュ機構を備えたフィボナッチ数列計算関数", "description": "再帰を用いたフィボナッチ数列計算の最適化関数において、アサーションとデバッグプリントを挿入することで、呼び出し履歴の追跡とキャッシュヒット率のモニタリングが可能になります。入力の検証、再帰呼び出しの追跡、キャッシュの利用状況をログ出力することで、パフォーマンス改善の効果を可視化します。", "keywords": ["fibonacci", "cache", "memoization", "recursion", "performance", "decorator"], "code_before": "def fibonacci(n, cache=None):\n    if cache is None:\n        cache = {}\n    if n in cache:\n        return cache[n]\n    if n <= 1:\n        return n\n    cache[n] = fibonacci(n-1, cache) + fibonacci(n-2, cache)\n    return cache[n]", "code_after": "def fibonacci(n, cache=None, _depth=0):\n    # 入力値の検証\n    assert isinstance(n, int), f\"Input must be an integer, got {type(n)}\"\n    assert n >= 0, f\"Input must be non-negative, got {n}\"\n    \n    # キャッシュの初期化とデバッグ情報\n    if cache is None:\n        cache = {}\n        print(f\"[DEBUG] Starting fibonacci calculation for n={n}\")\n    \n    # インデントを使って再帰の深さを視覚化\n    indent = \"  \" * _depth\n    print(f\"{indent}[DEBUG] Computing fibonacci({n}) at depth {_depth}\")\n    \n    # キャッシュヒットの確認と報告\n    if n in cache:\n        print(f\"{indent}[DEBUG] Cache hit for fibonacci({n}) = {cache[n]}\")\n        return cache[n]\n    \n    # 基底ケースの処理\n    if n <= 1:\n        result = n\n        print(f\"{indent}[DEBUG] Base case: fibonacci({n}) = {result}\")\n        return result\n    \n    # 再帰呼び出しとキャッシュへの格納\n    result = fibonacci(n-1, cache, _depth+1) + fibonacci(n-2, cache, _depth+1)\n    cache[n] = result\n    \n    # 計算結果のレポート\n    print(f\"{indent}[DEBUG] Computed and cached: fibonacci({n}) = {result}\")\n    \n    # 最初の呼び出しが完了したときに統計情報を表示\n    if _depth == 0:\n        cache_hits = len(cache)\n        print(f\"[DEBUG] Fibonacci calculation complete with {cache_hits} cache entries\")\n        print(f\"[DEBUG] Cache contents: {cache}\")\n    \n    return result", "test_cases": {"success": [{"input": ["5"], "expected_output": "5"}, {"input": ["10"], "expected_output": "55"}, {"input": ["0"], "expected_output": "0"}], "failure": [{"input": ["-1"], "expected_exception": "AssertionError", "expected_message_part": "Input must be non-negative"}, {"input": ["'5'"], "expected_exception": "AssertionError", "expected_message_part": "Input must be an integer"}]}}
{"title": "文字列からの金額抽出と通貨変換関数", "description": "テキストから金額を抽出し、指定された通貨レートで変換する関数です。アサーションは入力パラメータの妥当性を検証し、デバッグプリントは正規表現マッチングの過程と通貨変換の各ステップを追跡します。複雑な正規表現処理と数値変換を含む関数では、中間結果の可視化が特に重要です。", "keywords": ["regex", "currency", "extraction", "conversion", "text processing", "pattern matching"], "code_before": "import re\n\ndef extract_and_convert_currency(text, target_currency, exchange_rates):\n    # 金額とその通貨コードを抽出する正規表現\n    pattern = r'([\\d,\\.]+)\\s*([A-Z]{3})'\n    matches = re.findall(pattern, text)\n    \n    results = []\n    for amount_str, currency in matches:\n        # 数値に変換\n        amount = float(amount_str.replace(',', ''))\n        \n        # 通貨変換\n        if currency != target_currency:\n            if currency in exchange_rates and target_currency in exchange_rates:\n                # 基準通貨（USD）を介して変換\n                amount_in_usd = amount / exchange_rates[currency]\n                converted_amount = amount_in_usd * exchange_rates[target_currency]\n            else:\n                converted_amount = None\n        else:\n            converted_amount = amount\n            \n        results.append((amount, currency, converted_amount))\n        \n    return results", "code_after": "import re\n\ndef extract_and_convert_currency(text, target_currency, exchange_rates):\n    print(f\"[DEBUG] Starting currency extraction from: '{text}'\")\n    print(f\"[DEBUG] Target currency: {target_currency}\")\n    print(f\"[DEBUG] Available exchange rates: {exchange_rates}\")\n    \n    # 入力パラメータの検証\n    assert isinstance(text, str), f\"Text must be a string, got {type(text)}\"\n    assert isinstance(target_currency, str), f\"Target currency must be a string, got {type(target_currency)}\"\n    assert len(target_currency) == 3, f\"Currency code must be 3 characters, got '{target_currency}'\"\n    assert target_currency.isupper(), f\"Currency code must be uppercase, got '{target_currency}'\"\n    assert isinstance(exchange_rates, dict), f\"Exchange rates must be a dictionary, got {type(exchange_rates)}\"\n    \n    # 金額とその通貨コードを抽出する正規表現\n    pattern = r'([\\d,\\.]+)\\s*([A-Z]{3})'\n    print(f\"[DEBUG] Using regex pattern: {pattern}\")\n    \n    matches = re.findall(pattern, text)\n    print(f\"[DEBUG] Found {len(matches)} currency mentions: {matches}\")\n    \n    results = []\n    for i, (amount_str, currency) in enumerate(matches):\n        print(f\"\\n[DEBUG] Processing match #{i+1}: {amount_str} {currency}\")\n        \n        # 数値フォーマットの検証\n        assert re.match(r'^[\\d,\\.]+$', amount_str), f\"Invalid amount format: '{amount_str}'\"\n        \n        # 数値に変換\n        try:\n            amount = float(amount_str.replace(',', ''))\n            print(f\"[DEBUG] Converted '{amount_str}' to number: {amount}\")\n        except ValueError as e:\n            print(f\"[ERROR] Failed to convert '{amount_str}' to float: {e}\")\n            raise\n        \n        # 通貨コードの検証\n        assert len(currency) == 3 and currency.isupper(), f\"Invalid currency code: '{currency}'\"\n        \n        # 通貨変換\n        if currency != target_currency:\n            print(f\"[DEBUG] Currency conversion needed: {currency} → {target_currency}\")\n            \n            # 為替レートの存在確認\n            if currency not in exchange_rates:\n                print(f\"[WARNING] Exchange rate for {currency} not found\")\n            if target_currency not in exchange_rates:\n                print(f\"[WARNING] Exchange rate for {target_currency} not found\")\n            \n            if currency in exchange_rates and target_currency in exchange_rates:\n                # 基準通貨（USD）を介して変換\n                amount_in_usd = amount / exchange_rates[currency]\n                print(f\"[DEBUG] Converted to USD: {amount} {currency} = {amount_in_usd} USD\")\n                \n                converted_amount = amount_in_usd * exchange_rates[target_currency]\n                print(f\"[DEBUG] Converted to {target_currency}: {amount_in_usd} USD = {converted_amount} {target_currency}\")\n            else:\n                converted_amount = None\n                print(f\"[DEBUG] Conversion not possible due to missing exchange rates\")\n        else:\n            converted_amount = amount\n            print(f\"[DEBUG] No conversion needed (already in {target_currency})\")\n            \n        print(f\"[DEBUG] Adding to results: ({amount}, {currency}, {converted_amount})\")\n        results.append((amount, currency, converted_amount))\n    \n    print(f\"\\n[DEBUG] Extraction and conversion complete. Found {len(results)} results\")\n    return results", "test_cases": {"success": [{"input": ["'The product costs 100 USD and 75 EUR'", "'JPY'", "{'USD': 0.007, 'EUR': 0.008, 'JPY': 1.0}"], "expected_output": "[(100.0, 'USD', 14285.714285714286), (75.0, 'EUR', 9375.0)]"}, {"input": ["'The price is 50.75 USD'", "'USD'", "{'USD': 1.0, 'EUR': 0.85}"], "expected_output": "[(50.75, 'USD', 50.75)]"}], "failure": [{"input": ["123", "'USD'", "{'USD': 1.0}"], "expected_exception": "AssertionError", "expected_message_part": "Text must be a string"}, {"input": ["'100 USD'", "'us'", "{'USD': 1.0}"], "expected_exception": "AssertionError", "expected_message_part": "Currency code must be uppercase"}, {"input": ["'100 USD'", "'USDT'", "{'USD': 1.0}"], "expected_exception": "AssertionError", "expected_message_part": "Currency code must be 3 characters"}, {"input": ["'100 USD'", "'USD'", "'not a dict'"], "expected_exception": "AssertionError", "expected_message_part": "Exchange rates must be a dictionary"}, {"input": ["'Invalid amount 12,34.56 USD'", "'EUR'", "{'USD': 1.0, 'EUR': 0.85}"], "expected_exception": "AssertionError", "expected_message_part": "Invalid amount format"}]}}
{"title": "ネットワークパケット解析と検証関数", "description": "ネットワークパケットのバイト列を解析する関数に対して、バイト列の形式検証と処理状況のトレース機能を追加しました。入力データの検証、解析の各ステップでの中間状態の表示、および戻り値の整合性チェックを行います。バイナリデータ処理のような低レベル操作では、このようなデバッグ支援が特に重要です。", "keywords": ["bytes", "network", "packet", "struct", "unpack", "bytearray", "len", "slicing"], "code_before": "def parse_network_packet(packet_data):\n    header = packet_data[0:4]\n    packet_type = header[0]\n    packet_length = (header[1] << 8) | header[2]\n    checksum = header[3]\n    \n    if len(packet_data) < packet_length:\n        return None\n    \n    payload = packet_data[4:packet_length]\n    \n    if packet_type == 0x01:  # DATA packet\n        sequence_number = (payload[0] << 8) | payload[1]\n        data = payload[2:]\n        return {'type': 'DATA', 'sequence': sequence_number, 'data': data}\n    \n    elif packet_type == 0x02:  # ACK packet\n        ack_number = (payload[0] << 8) | payload[1]\n        return {'type': 'ACK', 'ack': ack_number}\n    \n    elif packet_type == 0x03:  # ERROR packet\n        error_code = (payload[0] << 8) | payload[1]\n        error_message = payload[2:].decode('utf-8', errors='ignore')\n        return {'type': 'ERROR', 'code': error_code, 'message': error_message}\n    \n    return None", "code_after": "def parse_network_packet(packet_data):\n    print(f\"[DEBUG] Starting to parse packet of length {len(packet_data)} bytes\")\n    \n    # Input validation\n    assert isinstance(packet_data, (bytes, bytearray)), \"packet_data must be bytes or bytearray\"\n    assert len(packet_data) >= 4, \"packet_data must be at least 4 bytes for header\"\n    \n    header = packet_data[0:4]\n    packet_type = header[0]\n    packet_length = (header[1] << 8) | header[2]\n    checksum = header[3]\n    \n    print(f\"[DEBUG] Header parsed: type=0x{packet_type:02x}, length={packet_length}, checksum=0x{checksum:02x}\")\n    \n    # Validate packet length\n    assert packet_length > 0, \"Invalid packet length (must be > 0)\"\n    assert packet_length <= 65535, \"Packet length exceeds maximum allowed (65535 bytes)\"\n    \n    if len(packet_data) < packet_length:\n        print(f\"[DEBUG] Packet data incomplete: expected {packet_length} bytes, got {len(packet_data)}\")\n        return None\n    \n    payload = packet_data[4:packet_length]\n    print(f\"[DEBUG] Extracted payload of {len(payload)} bytes\")\n    \n    result = None\n    \n    if packet_type == 0x01:  # DATA packet\n        assert len(payload) >= 2, \"DATA packet must have at least 2 bytes for sequence number\"\n        sequence_number = (payload[0] << 8) | payload[1]\n        data = payload[2:]\n        print(f\"[DEBUG] Parsed DATA packet: sequence={sequence_number}, data_length={len(data)}\")\n        result = {'type': 'DATA', 'sequence': sequence_number, 'data': data}\n    \n    elif packet_type == 0x02:  # ACK packet\n        assert len(payload) >= 2, \"ACK packet must have at least 2 bytes for ack number\"\n        ack_number = (payload[0] << 8) | payload[1]\n        print(f\"[DEBUG] Parsed ACK packet: ack={ack_number}\")\n        result = {'type': 'ACK', 'ack': ack_number}\n    \n    elif packet_type == 0x03:  # ERROR packet\n        assert len(payload) >= 2, \"ERROR packet must have at least 2 bytes for error code\"\n        error_code = (payload[0] << 8) | payload[1]\n        error_message = payload[2:].decode('utf-8', errors='ignore')\n        print(f\"[DEBUG] Parsed ERROR packet: code={error_code}, message='{error_message}'\")\n        result = {'type': 'ERROR', 'code': error_code, 'message': error_message}\n    \n    else:\n        print(f\"[DEBUG] Unknown packet type: 0x{packet_type:02x}\")\n    \n    print(f\"[DEBUG] Packet parsing completed, result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["b'\\x01\\x00\\x0a\\x00\\x00\\x01hello'"], "expected_output": "{'type': 'DATA', 'sequence': 1, 'data': b'hello'}"}, {"input": ["b'\\x02\\x00\\x06\\x00\\x00\\x05'"], "expected_output": "{'type': 'ACK', 'ack': 5}"}, {"input": ["b'\\x03\\x00\\x0f\\x00\\x00\\x01Error text'"], "expected_output": "{'type': 'ERROR', 'code': 1, 'message': 'Error text'}"}], "failure": [{"input": ["'not bytes'"], "expected_exception": "AssertionError", "expected_message_part": "packet_data must be bytes or bytearray"}, {"input": ["b'\\x01\\x02'"], "expected_exception": "AssertionError", "expected_message_part": "packet_data must be at least 4 bytes for header"}, {"input": ["b'\\x01\\x00\\x00\\x00'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid packet length (must be > 0)"}, {"input": ["b'\\x01\\xff\\xff\\x00\\x00'"], "expected_exception": "AssertionError", "expected_message_part": "Packet length exceeds maximum allowed"}, {"input": ["b'\\x01\\x00\\x08\\x00'"], "expected_exception": "AssertionError", "expected_message_part": "DATA packet must have at least 2 bytes for sequence number"}]}}
{"title": "グラフ探索アルゴリズム（深さ優先探索）", "description": "グラフ探索アルゴリズムの実装では、グラフの構造と入力パラメータが妥当かどうかを検証する必要があります。このパターンでは、隣接リストの形式チェック、開始ノードの存在確認、訪問済みノードの追跡などにアサーションとデバッグプリントを追加し、アルゴリズムの実行過程を可視化します。", "keywords": ["graph", "dfs", "depth-first search", "adjacency list", "recursion", "visited"], "code_before": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    \n    for next_node in graph.get(start, []):\n        if next_node not in visited:\n            dfs(graph, next_node, visited)\n    \n    return visited", "code_after": "def dfs(graph, start, visited=None):\n    # アサーション: グラフはdict型である\n    assert isinstance(graph, dict), f\"Graph must be a dictionary, got {type(graph)}\"\n    # アサーション: 開始ノードがグラフに存在する\n    assert start in graph, f\"Start node {start} does not exist in the graph\"\n    # アサーション: 各隣接リストはイテラブルである\n    for node, neighbors in graph.items():\n        assert hasattr(neighbors, '__iter__'), f\"Neighbors of node {node} must be iterable, got {type(neighbors)}\"\n    \n    print(f\"Starting DFS from node {start}\")\n    \n    if visited is None:\n        visited = set()\n        print(f\"Initializing visited set: {visited}\")\n    \n    print(f\"Visiting node {start}\")\n    visited.add(start)\n    print(f\"Updated visited set: {visited}\")\n    \n    for next_node in graph.get(start, []):\n        print(f\"Considering edge: {start} -> {next_node}\")\n        if next_node not in visited:\n            print(f\"Node {next_node} not visited yet, recursing...\")\n            dfs(graph, next_node, visited)\n        else:\n            print(f\"Node {next_node} already visited, skipping\")\n    \n    print(f\"Completed exploration from node {start}\")\n    return visited", "test_cases": {"success": [{"input": ["{1: [2, 3], 2: [4], 3: [4], 4: []}", "1"], "expected_output": "{1, 2, 3, 4}"}, {"input": ["{1: [2], 2: [1, 3], 3: []}", "2"], "expected_output": "{1, 2, 3}"}], "failure": [{"input": ["[1, 2, 3]", "1"], "expected_exception": "AssertionError", "expected_message_part": "Graph must be a dictionary"}, {"input": ["{1: [2, 3], 2: [4], 3: [4], 4: []}", "5"], "expected_exception": "AssertionError", "expected_message_part": "does not exist in the graph"}, {"input": ["{1: 2, 2: [1]}", "1"], "expected_exception": "AssertionError", "expected_message_part": "must be iterable"}]}}
{"title": "ファイル圧縮と解凍を行う関数", "description": "ファイル操作を伴う関数では、ファイルの存在確認、パスの検証、操作権限のチェックが重要です。このパターンでは、入力ファイルパスの存在確認、出力パスの書き込み権限、ファイルサイズの妥当性チェックなどにアサーションを使用し、処理の各段階でのファイル状態をデバッグプリントで追跡します。", "keywords": ["file", "compression", "zip", "gzip", "os.path", "with", "open", "shutil"], "code_before": "import os\nimport gzip\nimport shutil\n\ndef compress_file(input_path, output_path=None, delete_original=False):\n    if output_path is None:\n        output_path = input_path + '.gz'\n    \n    with open(input_path, 'rb') as f_in:\n        with gzip.open(output_path, 'wb') as f_out:\n            shutil.copyfileobj(f_in, f_out)\n    \n    if delete_original:\n        os.remove(input_path)\n    \n    return output_path", "code_after": "import os\nimport gzip\nimport shutil\nimport stat\n\ndef compress_file(input_path, output_path=None, delete_original=False):\n    # アサーション: 入力パスが文字列である\n    assert isinstance(input_path, str), f\"Input path must be a string, got {type(input_path)}\"\n    # アサーション: 入力ファイルが存在する\n    assert os.path.exists(input_path), f\"Input file does not exist: {input_path}\"\n    # アサーション: 入力パスがファイルである\n    assert os.path.isfile(input_path), f\"Input path is not a file: {input_path}\"\n    # アサーション: 入力ファイルが読み取り可能である\n    assert os.access(input_path, os.R_OK), f\"Input file is not readable: {input_path}\"\n    # アサーション: 入力ファイルが空でない\n    assert os.path.getsize(input_path) > 0, f\"Input file is empty: {input_path}\"\n    \n    print(f\"Starting compression of file: {input_path}\")\n    print(f\"Original file size: {os.path.getsize(input_path)} bytes\")\n    \n    if output_path is None:\n        output_path = input_path + '.gz'\n        print(f\"No output path specified, defaulting to: {output_path}\")\n    else:\n        # アサーション: 出力パスが文字列である\n        assert isinstance(output_path, str), f\"Output path must be a string, got {type(output_path)}\"\n    \n    # 出力ディレクトリの存在確認\n    output_dir = os.path.dirname(output_path) or '.'\n    if not os.path.exists(output_dir):\n        print(f\"Output directory does not exist, creating: {output_dir}\")\n        os.makedirs(output_dir)\n    \n    # アサーション: 出力ディレクトリに書き込み権限がある\n    assert os.access(output_dir, os.W_OK), f\"No write permission to output directory: {output_dir}\"\n    \n    print(f\"Compressing {input_path} to {output_path}\")\n    try:\n        with open(input_path, 'rb') as f_in:\n            print(f\"Opened input file: {input_path}\")\n            with gzip.open(output_path, 'wb') as f_out:\n                print(f\"Opened output file: {output_path}\")\n                shutil.copyfileobj(f_in, f_out)\n                print(\"File content copied and compressed\")\n    except Exception as e:\n        print(f\"Error during compression: {str(e)}\")\n        # 失敗した場合、部分的に作成された出力ファイルを削除\n        if os.path.exists(output_path):\n            os.remove(output_path)\n        raise\n    \n    # 圧縮後のサイズを確認\n    compressed_size = os.path.getsize(output_path)\n    print(f\"Compressed file size: {compressed_size} bytes\")\n    \n    if delete_original:\n        print(f\"Deleting original file: {input_path}\")\n        # アサーション: 元ファイルに書き込み権限がある（削除に必要）\n        assert os.access(input_path, os.W_OK), f\"No write permission to delete original file: {input_path}\"\n        os.remove(input_path)\n        print(f\"Original file deleted\")\n    \n    print(f\"Compression completed successfully\")\n    return output_path", "test_cases": {"success": [{"input": ["'test_file.txt'", "None", "False"], "expected_output": "'test_file.txt.gz'"}, {"input": ["'test_file.txt'", "'compressed/test.gz'", "True"], "expected_output": "'compressed/test.gz'"}], "failure": [{"input": ["123", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "Input path must be a string"}, {"input": ["'non_existent_file.txt'", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "Input file does not exist"}, {"input": ["'/'", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "Input path is not a file"}, {"input": ["'empty_file.txt'", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "Input file is empty"}, {"input": ["'test_file.txt'", "'/root/no_permission.gz'", "False"], "expected_exception": "AssertionError", "expected_message_part": "No write permission to output directory"}, {"input": ["'read_only.txt'", "None", "True"], "expected_exception": "AssertionError", "expected_message_part": "No write permission to delete original file"}]}}
{"title": "CSVファイル処理と行検証関数", "description": "CSVファイルの行データを処理する関数にアサーションとデバッグを追加します。入力パラメータの型検証、必須フィールドの存在確認、処理過程の追跡ログ、そして結果の整合性検証を組み込みます。このパターンは、データ変換処理を行う関数で、特に複数のバリデーションやフィルタリングが必要な場合に有効です。", "keywords": ["csv", "データ検証", "フィルタリング", "文字列操作", "リスト内包表記"], "code_before": "def process_csv_records(csv_data, required_fields=None, filters=None):\n    # CSVデータから有効な行を処理する\n    if required_fields is None:\n        required_fields = []\n    if filters is None:\n        filters = {}\n        \n    valid_records = []\n    for row in csv_data:\n        # 必須フィールドの確認\n        if all(field in row for field in required_fields):\n            # フィルター条件の適用\n            if all(row.get(key) == value for key, value in filters.items()):\n                # データの整形と追加\n                processed_row = {k: v.strip() if isinstance(v, str) else v for k, v in row.items()}\n                valid_records.append(processed_row)\n                \n    return valid_records", "code_after": "def process_csv_records(csv_data, required_fields=None, filters=None):\n    # CSVデータから有効な行を処理する\n    print(f\"処理開始: {len(csv_data) if csv_data else 0}行のCSVデータを処理します\")\n    \n    # 入力パラメータの検証\n    assert csv_data is not None, \"csv_dataはNoneであってはなりません\"\n    assert isinstance(csv_data, list), f\"csv_dataはリスト型である必要があります。現在の型: {type(csv_data)}\"\n    \n    if required_fields is None:\n        required_fields = []\n    else:\n        assert isinstance(required_fields, list), f\"required_fieldsはリスト型である必要があります。現在の型: {type(required_fields)}\"\n        print(f\"必須フィールド: {required_fields}\")\n    \n    if filters is None:\n        filters = {}\n    else:\n        assert isinstance(filters, dict), f\"filtersは辞書型である必要があります。現在の型: {type(filters)}\"\n        print(f\"フィルター条件: {filters}\")\n        \n    valid_records = []\n    invalid_count = 0\n    filtered_out_count = 0\n    \n    for i, row in enumerate(csv_data):\n        print(f\"行 {i+1} 処理中: {row}\")\n        \n        # 行データの検証\n        assert isinstance(row, dict), f\"各行は辞書型である必要があります。行 {i+1} の型: {type(row)}\"\n        \n        # 必須フィールドの確認\n        missing_fields = [field for field in required_fields if field not in row]\n        if missing_fields:\n            print(f\"行 {i+1}: 必須フィールド {missing_fields} がありません - スキップします\")\n            invalid_count += 1\n            continue\n            \n        if all(field in row for field in required_fields):\n            print(f\"行 {i+1}: すべての必須フィールドが存在します\")\n            \n            # フィルター条件の適用\n            filter_failed = False\n            for key, value in filters.items():\n                if row.get(key) != value:\n                    print(f\"行 {i+1}: フィルター条件 '{key}={value}' に一致しません - スキップします\")\n                    filter_failed = True\n                    break\n                    \n            if filter_failed:\n                filtered_out_count += 1\n                continue\n                \n            if all(row.get(key) == value for key, value in filters.items()):\n                print(f\"行 {i+1}: すべてのフィルター条件に一致しました\")\n                \n                # データの整形と追加\n                processed_row = {k: v.strip() if isinstance(v, str) else v for k, v in row.items()}\n                print(f\"行 {i+1}: 処理後のデータ: {processed_row}\")\n                valid_records.append(processed_row)\n                \n    print(f\"処理完了: 合計{len(csv_data)}行中、有効な行は{len(valid_records)}行です\")\n    print(f\"無効な行: {invalid_count}、フィルターで除外された行: {filtered_out_count}\")\n    return valid_records", "test_cases": {"success": [{"input": ["[{'name': 'John', 'age': '30', 'city': 'New York'}, {'name': 'Alice', 'age': '25', 'city': 'Boston'}]", "['name', 'age']", "{}"], "expected_output": "[{'name': 'John', 'age': '30', 'city': 'New York'}, {'name': 'Alice', 'age': '25', 'city': 'Boston'}]"}, {"input": ["[{'name': 'John', 'age': '30', 'city': 'New York'}, {'name': 'Alice', 'age': '25', 'city': 'Boston'}]", "['name']", "{'city': 'Boston'}"], "expected_output": "[{'name': 'Alice', 'age': '25', 'city': 'Boston'}]"}, {"input": ["[{'name': 'John ', 'age': '30', 'city': ' New York '}, {'name': ' Alice', 'age': '25', 'city': 'Boston'}]", "[]", "{}"], "expected_output": "[{'name': 'John', 'age': '30', 'city': 'New York'}, {'name': 'Alice', 'age': '25', 'city': 'Boston'}]"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "csv_dataはNoneであってはなりません"}, {"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "csv_dataはリスト型である必要があります"}, {"input": ["[{'name': 'John'}]", "'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "required_fieldsはリスト型である必要があります"}, {"input": ["[{'name': 'John'}]", "[]", "'not a dict'"], "expected_exception": "AssertionError", "expected_message_part": "filtersは辞書型である必要があります"}, {"input": ["[123]"], "expected_exception": "AssertionError", "expected_message_part": "各行は辞書型である必要があります"}]}}
{"title": "テキスト分析による感情分類関数", "description": "テキスト文字列の感情分析を行う関数にアサーションとデバッグプリントを追加します。入力テキストの検証、感情分析のアルゴリズム処理の各ステップ、そして最終結果の出力における詳細なログを提供します。このパターンは、複雑なテキスト処理と自然言語処理のフローを持つ関数に特に有効です。", "keywords": ["テキスト分析", "感情分析", "NLP", "文字列処理", "正規表現"], "code_before": "def analyze_sentiment(text, positive_words=None, negative_words=None, neutral_threshold=0.1):\n    if positive_words is None:\n        positive_words = ['good', 'great', 'excellent', 'happy', 'positive']\n    if negative_words is None:\n        negative_words = ['bad', 'awful', 'terrible', 'sad', 'negative']\n    \n    # テキストの前処理\n    text = text.lower()\n    words = text.split()\n    \n    # 感情スコアの計算\n    positive_count = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n    \n    total_words = len(words)\n    if total_words == 0:\n        return 'neutral'\n    \n    positive_score = positive_count / total_words\n    negative_score = negative_count / total_words\n    \n    # 感情の判定\n    sentiment_diff = positive_score - negative_score\n    \n    if abs(sentiment_diff) <= neutral_threshold:\n        return 'neutral'\n    elif sentiment_diff > 0:\n        return 'positive'\n    else:\n        return 'negative'", "code_after": "def analyze_sentiment(text, positive_words=None, negative_words=None, neutral_threshold=0.1):\n    print(f\"感情分析開始: テキスト長={len(text) if text else 0}文字\")\n    \n    # 入力パラメータの検証\n    assert text is not None, \"テキストはNoneであってはなりません\"\n    assert isinstance(text, str), f\"テキストは文字列である必要があります。現在の型: {type(text)}\"\n    assert len(text.strip()) > 0, \"テキストは空であってはなりません\"\n    \n    assert isinstance(neutral_threshold, (int, float)), f\"neutral_thresholdは数値である必要があります。現在の型: {type(neutral_threshold)}\"\n    assert 0 <= neutral_threshold <= 1, f\"neutral_thresholdは0から1の間である必要があります。現在の値: {neutral_threshold}\"\n    \n    print(f\"中立閾値: {neutral_threshold}\")\n    \n    if positive_words is None:\n        positive_words = ['good', 'great', 'excellent', 'happy', 'positive']\n    else:\n        assert isinstance(positive_words, list), f\"positive_wordsはリスト型である必要があります。現在の型: {type(positive_words)}\"\n        assert all(isinstance(word, str) for word in positive_words), \"positive_wordsの全要素は文字列である必要があります\"\n    \n    print(f\"ポジティブ単語リスト: {positive_words}\")\n    \n    if negative_words is None:\n        negative_words = ['bad', 'awful', 'terrible', 'sad', 'negative']\n    else:\n        assert isinstance(negative_words, list), f\"negative_wordsはリスト型である必要があります。現在の型: {type(negative_words)}\"\n        assert all(isinstance(word, str) for word in negative_words), \"negative_wordsの全要素は文字列である必要があります\"\n    \n    print(f\"ネガティブ単語リスト: {negative_words}\")\n    \n    # テキストの前処理\n    print(f\"テキスト前処理前: '{text}'\")\n    text = text.lower()\n    print(f\"小文字変換後: '{text}'\")\n    words = text.split()\n    print(f\"単語分割結果: {words}\")\n    \n    # 感情スコアの計算\n    positive_matches = [word for word in words if word in positive_words]\n    positive_count = len(positive_matches)\n    print(f\"ポジティブ単語の出現: {positive_count}個 {positive_matches if positive_matches else ''}\")\n    \n    negative_matches = [word for word in words if word in negative_words]\n    negative_count = len(negative_matches)\n    print(f\"ネガティブ単語の出現: {negative_count}個 {negative_matches if negative_matches else ''}\")\n    \n    total_words = len(words)\n    print(f\"総単語数: {total_words}語\")\n    \n    if total_words == 0:\n        print(\"警告: テキストに単語が含まれていません\")\n        return 'neutral'\n    \n    positive_score = positive_count / total_words\n    negative_score = negative_count / total_words\n    \n    print(f\"ポジティブスコア: {positive_score:.4f}\")\n    print(f\"ネガティブスコア: {negative_score:.4f}\")\n    \n    # 感情の判定\n    sentiment_diff = positive_score - negative_score\n    print(f\"感情差分: {sentiment_diff:.4f}\")\n    \n    result = ''\n    if abs(sentiment_diff) <= neutral_threshold:\n        result = 'neutral'\n    elif sentiment_diff > 0:\n        result = 'positive'\n    else:\n        result = 'negative'\n    \n    print(f\"分析結果: '{result}'\")\n    return result", "test_cases": {"success": [{"input": ["'This is a good and excellent day!'"], "expected_output": "'positive'"}, {"input": ["'This is a terrible and awful experience.'"], "expected_output": "'negative'"}, {"input": ["'This is just a normal day.'"], "expected_output": "'neutral'"}, {"input": ["'Happy and sad moments mixed together.'", "['happy', 'joy']", "['sad', 'miserable']", "0.05"], "expected_output": "'neutral'"}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "テキストはNoneであってはなりません"}, {"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "テキストは文字列である必要があります"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "テキストは空であってはなりません"}, {"input": ["'Hello'", "{'not': 'a list'}"], "expected_exception": "AssertionError", "expected_message_part": "positive_wordsはリスト型である必要があります"}, {"input": ["'Hello'", "['good']", "['bad', 123]"], "expected_exception": "AssertionError", "expected_message_part": "negative_wordsの全要素は文字列である必要があります"}, {"input": ["'Hello'", "['good']", "['bad']", "2.0"], "expected_exception": "AssertionError", "expected_message_part": "neutral_thresholdは0から1の間である必要があります"}]}}
