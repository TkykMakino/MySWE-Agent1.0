{"description": "このパターンは、リスト操作を行う関数において、入力値の型チェックと有効範囲の検証を行います。特に、リストが空でないこと、および操作対象のインデックスが範囲内にあることを確認します。デバッグプリントは関数の開始、中間状態、終了時の値を表示し、実行フローの追跡を容易にします。", "keywords": ["list", "index", "slice", "range"], "code_before": "def get_nth_element(lst, n):\n    return lst[n]", "code_after": "def get_nth_element(lst, n):\n    print(f\"Starting get_nth_element with lst={lst}, n={n}\")\n    \n    # 入力値の検証\n    assert isinstance(lst, list), f\"Expected list but got {type(lst).__name__}\"\n    assert len(lst) > 0, \"List cannot be empty\"\n    assert isinstance(n, int), f\"Index must be an integer, got {type(n).__name__}\"\n    assert -len(lst) <= n < len(lst), f\"Index {n} out of range for list of length {len(lst)}\"\n    \n    print(f\"Accessing element at index {n}\")\n    result = lst[n]\n    print(f\"Returning result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]", "2"], "expected_output": "3"}, {"input": ["[1, 2, 3, 4, 5]", "-1"], "expected_output": "5"}], "failure": [{"input": ["[]", "0"], "expected_exception": "AssertionError", "expected_message_part": "List cannot be empty"}, {"input": ["[1, 2, 3]", "5"], "expected_exception": "AssertionError", "expected_message_part": "Index 5 out of range"}, {"input": ["[1, 2, 3]", "'a'"], "expected_exception": "AssertionError", "expected_message_part": "Index must be an integer"}, {"input": ["'hello'", "1"], "expected_exception": "AssertionError", "expected_message_part": "Expected list"}]}}
{"description": "文字列操作を行う関数における入力検証と実行追跡の例です。このパターンは、文字列を特定の長さで分割する際に、入力パラメータの妥当性（文字列型であること、分割長が正の整数であること）を確認します。また、各ステップでの文字列操作の状態を詳細に追跡するためのデバッグプリントも含まれています。", "keywords": ["string", "split", "chunks", "length"], "code_before": "def split_string_into_chunks(text, chunk_size):\n    chunks = []\n    for i in range(0, len(text), chunk_size):\n        chunks.append(text[i:i+chunk_size])\n    return chunks", "code_after": "def split_string_into_chunks(text, chunk_size):\n    print(f\"Starting split_string_into_chunks with text='{text}', chunk_size={chunk_size}\")\n    \n    # 入力パラメータの検証\n    assert isinstance(text, str), f\"Expected string but got {type(text).__name__}\"\n    assert isinstance(chunk_size, int), f\"Chunk size must be an integer, got {type(chunk_size).__name__}\"\n    assert chunk_size > 0, f\"Chunk size must be positive, got {chunk_size}\"\n    \n    chunks = []\n    text_length = len(text)\n    print(f\"Processing string of length {text_length}\")\n    \n    for i in range(0, text_length, chunk_size):\n        current_chunk = text[i:i+chunk_size]\n        print(f\"  Creating chunk {i//chunk_size + 1}: '{current_chunk}'\")\n        chunks.append(current_chunk)\n    \n    print(f\"Returning {len(chunks)} chunks: {chunks}\")\n    return chunks", "test_cases": {"success": [{"input": ["'HelloWorld'", "5"], "expected_output": "['Hello', 'World']"}, {"input": ["'abcdefghi'", "2"], "expected_output": "['ab', 'cd', 'ef', 'gh', 'i']"}, {"input": ["''", "3"], "expected_output": "[]"}], "failure": [{"input": ["123", "3"], "expected_exception": "AssertionError", "expected_message_part": "Expected string"}, {"input": ["'hello'", "'3'"], "expected_exception": "AssertionError", "expected_message_part": "Chunk size must be an integer"}, {"input": ["'hello'", "0"], "expected_exception": "AssertionError", "expected_message_part": "Chunk size must be positive"}]}}
{"description": "辞書操作関数におけるキー存在確認と値検証のパターンです。特に、必須キーの存在チェック、値の型チェック、および計算結果の論理的妥当性を検証します。デバッグプリントは辞書の内容確認や計算過程の可視化に役立ちます。このパターンは、設定ファイルの解析やAPIレスポンスの処理など、外部データを扱う場面で特に有効です。", "keywords": ["dict", "keys", "values", "calculation"], "code_before": "def calculate_area(rectangle_data):\n    width = rectangle_data['width']\n    height = rectangle_data['height']\n    return width * height", "code_after": "def calculate_area(rectangle_data):\n    print(f\"Starting calculate_area with data: {rectangle_data}\")\n    \n    # 入力辞書の検証\n    assert isinstance(rectangle_data, dict), f\"Expected dictionary but got {type(rectangle_data).__name__}\"\n    assert 'width' in rectangle_data, \"Missing required key 'width'\"\n    assert 'height' in rectangle_data, \"Missing required key 'height'\"\n    \n    width = rectangle_data['width']\n    height = rectangle_data['height']\n    \n    # 値の検証\n    assert isinstance(width, (int, float)), f\"Width must be a number, got {type(width).__name__}\"\n    assert isinstance(height, (int, float)), f\"Height must be a number, got {type(height).__name__}\"\n    assert width > 0, f\"Width must be positive, got {width}\"\n    assert height > 0, f\"Height must be positive, got {height}\"\n    \n    print(f\"Calculating area with width={width}, height={height}\")\n    area = width * height\n    print(f\"Area calculated: {area}\")\n    \n    return area", "test_cases": {"success": [{"input": ["{'width': 5, 'height': 10}"], "expected_output": "50"}, {"input": ["{'width': 3.5, 'height': 2.0, 'color': 'red'}"], "expected_output": "7.0"}], "failure": [{"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "Missing required key 'width'"}, {"input": ["{'width': 5}"], "expected_exception": "AssertionError", "expected_message_part": "Missing required key 'height'"}, {"input": ["{'width': '5', 'height': 10}"], "expected_exception": "AssertionError", "expected_message_part": "Width must be a number"}, {"input": ["{'width': 0, 'height': 10}"], "expected_exception": "AssertionError", "expected_message_part": "Width must be positive"}, {"input": ["{'width': 5, 'height': -2}"], "expected_exception": "AssertionError", "expected_message_part": "Height must be positive"}, {"input": ["[5, 10]"], "expected_exception": "AssertionError", "expected_message_part": "Expected dictionary"}]}}
{"description": "このパターンは、ファイル操作関数における入力パスの検証とファイル処理の追跡に適しています。特に、ファイルパスの存在確認、形式チェック、およびファイル操作の各段階（オープン、読み込み、クローズ）を明示的に追跡します。このようなチェックとログは、ファイルが見つからない、アクセス権がないなどの実行時エラーを予防し、問題が発生した場合のデバッグを容易にします。", "keywords": ["file", "open", "read", "path"], "code_before": "def count_lines_in_file(file_path):\n    with open(file_path, 'r') as file:\n        lines = file.readlines()\n    return len(lines)", "code_after": "def count_lines_in_file(file_path):\n    print(f\"Starting count_lines_in_file with path: {file_path}\")\n    \n    # 入力パスの検証\n    assert isinstance(file_path, str), f\"Expected string path but got {type(file_path).__name__}\"\n    assert file_path.strip() != \"\", \"File path cannot be empty\"\n    \n    import os\n    assert os.path.exists(file_path), f\"File does not exist: {file_path}\"\n    assert os.path.isfile(file_path), f\"Path is not a file: {file_path}\"\n    \n    try:\n        print(f\"Opening file: {file_path}\")\n        with open(file_path, 'r') as file:\n            print(\"Reading file content\")\n            lines = file.readlines()\n            line_count = len(lines)\n            print(f\"File contains {line_count} lines\")\n        print(\"File closed successfully\")\n        return line_count\n    except Exception as e:\n        print(f\"Error during file operation: {e}\")\n        raise", "test_cases": {"success": [{"input": ["'test_file.txt'"], "expected_output": "5"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Expected string path"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "File path cannot be empty"}, {"input": ["'non_existent_file.txt'"], "expected_exception": "AssertionError", "expected_message_part": "File does not exist"}, {"input": ["'/'"], "expected_exception": "AssertionError", "expected_message_part": "Path is not a file"}]}}
{"description": "数値リスト内の最大値を見つける関数に、引数の型チェックとリストが空でないことを確認するアサーションを追加。また、処理開始、進行状況、結果を示すデバッグプリントを挿入しています。これは関数の入力検証と処理フローの可視化が重要な場面で有効です。", "keywords": ["list", "max", "for loop", "validation", "type check"], "code_before": "def find_max(numbers):\n    current_max = numbers[0]\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n    return current_max", "code_after": "def find_max(numbers):\n    print(f\"[DEBUG] Starting find_max with input: {numbers}\")\n    \n    # Validate input\n    assert isinstance(numbers, list), \"Input must be a list\"\n    assert len(numbers) > 0, \"Input list cannot be empty\"\n    assert all(isinstance(num, (int, float)) for num in numbers), \"All elements must be numbers\"\n    \n    current_max = numbers[0]\n    print(f\"[DEBUG] Initial max value: {current_max}\")\n    \n    for i, num in enumerate(numbers[1:]):\n        if num > current_max:\n            print(f\"[DEBUG] New max found at index {i+1}: {num} > {current_max}\")\n            current_max = num\n    \n    print(f\"[DEBUG] Final max value: {current_max}\")\n    return current_max", "test_cases": {"success": [{"input": ["[5, 2, 9, 1, 7]"], "expected_output": "9"}, {"input": ["[3.14, 2.71, 1.62]"], "expected_output": "3.14"}, {"input": ["[42]"], "expected_output": "42"}], "failure": [{"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a list"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "Input list cannot be empty"}, {"input": ["[1, 2, 'three']"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}]}}
{"description": "文字列処理関数に入力検証とデバッグトレースを追加しています。この関数は単語数をカウントするもので、入力が文字列であることを検証し、空文字の特殊処理も行います。各処理ステップでの中間状態がデバッグプリントで可視化されており、テキスト処理関数のデバッグに効果的なパターンです。", "keywords": ["string", "split", "count", "strip", "text processing"], "code_before": "def count_words(text):\n    words = text.strip().split()\n    return len(words)", "code_after": "def count_words(text):\n    print(f\"[DEBUG] count_words called with text of length: {len(str(text))}\")\n    \n    # Validate input\n    assert isinstance(text, str), \"Input must be a string\"\n    \n    # Handle empty string early\n    if not text.strip():\n        print(\"[DEBUG] Empty text detected, returning 0\")\n        return 0\n        \n    # Process text\n    print(f\"[DEBUG] Processing text: '{text[:20]}{'...' if len(text) > 20 else ''}'\")  \n    words = text.strip().split()\n    print(f\"[DEBUG] Found {len(words)} words: {words[:3]}{'...' if len(words) > 3 else ''}\")\n    \n    return len(words)", "test_cases": {"success": [{"input": ["'The quick brown fox jumps over the lazy dog'"], "expected_output": "9"}, {"input": ["'Hello world'"], "expected_output": "2"}, {"input": ["''"], "expected_output": "0"}, {"input": ["'   '"], "expected_output": "0"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a string"}]}}
{"description": "辞書からのデータ取得と変換を行う関数に対して、厳格な入力検証とキーの存在確認のアサーションを追加しています。必須キーの存在チェック、値の型チェックにより堅牢性を高め、デバッグプリントによって関数実行フローの可視化を実現しています。このパターンは、データ抽出や変換を行う関数で特に有効です。", "keywords": ["dict", "get", "key validation", "type conversion", "data extraction"], "code_before": "def extract_user_info(user_data):\n    name = user_data['name']\n    age = int(user_data['age'])\n    email = user_data.get('email', 'N/A')\n    \n    return {\n        'display_name': name.title(),\n        'is_adult': age >= 18,\n        'contact': email\n    }", "code_after": "def extract_user_info(user_data):\n    print(f\"[DEBUG] extract_user_info called with: {user_data}\")\n    \n    # Validate input\n    assert isinstance(user_data, dict), \"User data must be a dictionary\"\n    assert 'name' in user_data, \"Missing required field: 'name'\"\n    assert 'age' in user_data, \"Missing required field: 'age'\"\n    \n    # Extract and validate data\n    name = user_data['name']\n    assert isinstance(name, str), \"Name must be a string\"\n    print(f\"[DEBUG] Extracted name: {name}\")\n    \n    age_raw = user_data['age']\n    try:\n        age = int(age_raw)\n        print(f\"[DEBUG] Converted age to int: {age}\")\n    except ValueError:\n        assert False, f\"Age must be convertible to integer, got: {age_raw}\"\n    \n    email = user_data.get('email', 'N/A')\n    print(f\"[DEBUG] Using email: {email}\")\n    \n    result = {\n        'display_name': name.title(),\n        'is_adult': age >= 18,\n        'contact': email\n    }\n    \n    print(f\"[DEBUG] Returning result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["{\"name\": \"john doe\", \"age\": \"25\", \"email\": \"john@example.com\"}"], "expected_output": "{\"display_name\": \"John Doe\", \"is_adult\": True, \"contact\": \"john@example.com\"}"}, {"input": ["{\"name\": \"alice\", \"age\": 16}"], "expected_output": "{\"display_name\": \"Alice\", \"is_adult\": False, \"contact\": \"N/A\"}"}], "failure": [{"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "User data must be a dictionary"}, {"input": ["{\"age\": 30, \"email\": \"missing@name.com\"}"], "expected_exception": "AssertionError", "expected_message_part": "Missing required field: 'name'"}, {"input": ["{\"name\": \"bob\", \"email\": \"bob@example.com\"}"], "expected_exception": "AssertionError", "expected_message_part": "Missing required field: 'age'"}, {"input": ["{\"name\": 12345, \"age\": 25}"], "expected_exception": "AssertionError", "expected_message_part": "Name must be a string"}, {"input": ["{\"name\": \"charlie\", \"age\": \"invalid\"}"], "expected_exception": "AssertionError", "expected_message_part": "Age must be convertible to integer"}]}}
{"description": "再帰関数のデバッグを助けるアサーションとデバッグプリントのパターンです。フィボナッチ数列計算関数に再帰の深さを追跡するデバッグプリントと、入力の範囲チェックアサーションを追加しています。再帰関数特有の複雑な実行フローの可視化と、スタックオーバーフローを防ぐ入力検証に効果的です。", "keywords": ["recursion", "fibonacci", "depth tracking", "boundary check", "memoization"], "code_before": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)", "code_after": "def fibonacci(n, depth=0, memo={}):\n    indent = \"  \" * depth\n    print(f\"{indent}[DEBUG] Computing fibonacci({n}) at depth {depth}\")\n    \n    # Validate input\n    assert isinstance(n, int), \"Input must be an integer\"\n    assert n >= 0, \"Input must be a non-negative integer\"\n    assert depth < 100, \"Recursion too deep, possible infinite recursion\"\n    \n    # Base case\n    if n <= 1:\n        print(f\"{indent}[DEBUG] Base case: fibonacci({n}) = {n}\")\n        return n\n    \n    # Check memoization cache\n    if n in memo:\n        print(f\"{indent}[DEBUG] Using cached value for fibonacci({n}) = {memo[n]}\")\n        return memo[n]\n    \n    # Recursive case\n    print(f\"{indent}[DEBUG] Computing fibonacci({n-1}) + fibonacci({n-2})\")\n    result = fibonacci(n-1, depth+1, memo) + fibonacci(n-2, depth+1, memo)\n    \n    # Store in cache\n    memo[n] = result\n    print(f\"{indent}[DEBUG] fibonacci({n}) = {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["5"], "expected_output": "5"}, {"input": ["0"], "expected_output": "0"}, {"input": ["10"], "expected_output": "55"}], "failure": [{"input": ["'5'"], "expected_exception": "AssertionError", "expected_message_part": "Input must be an integer"}, {"input": ["-1"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a non-negative integer"}]}}
{"description": "リスト内の要素を処理する関数において、入力の型チェックと要素数の検証が重要です。この例では、リストの型、空でないこと、要素の型をアサーションで検証し、処理中の状態をデバッグプリントで追跡しています。これは特に入力パラメータの検証が重要な場合や、リスト処理のデバッグが必要な状況で役立ちます。", "keywords": ["list", "sum", "for", "len", "isinstance"], "code_before": "def calculate_average(numbers):\n    total = sum(numbers)\n    return total / len(numbers)", "code_after": "def calculate_average(numbers):\n    print(f\"Starting calculate_average with input: {numbers}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), \"Input must be a list\"\n    assert len(numbers) > 0, \"List cannot be empty\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"All elements must be numbers\"\n    \n    total = sum(numbers)\n    print(f\"Sum of all numbers: {total}\")\n    \n    result = total / len(numbers)\n    print(f\"Calculated average: {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "3.0"}, {"input": ["[10.5, 20.5, 30]"], "expected_output": "20.333333333333332"}], "failure": [{"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a list"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "List cannot be empty"}, {"input": ["[1, 2, '3']"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}]}}
{"description": "文字列操作関数において、パラメータの型や長さを検証し、処理過程を追跡することで、デバッグと保守が容易になります。特に複数の文字列操作を連続して行う場合に、中間状態の確認が重要です。", "keywords": ["string", "str.replace", "str.split", "str.join", "upper", "lower"], "code_before": "def format_name(full_name, capitalize=True):\n    parts = full_name.split()\n    if capitalize:\n        parts = [p.capitalize() for p in parts]\n    return ' '.join(parts)", "code_after": "def format_name(full_name, capitalize=True):\n    print(f\"Starting format_name with: full_name='{full_name}', capitalize={capitalize}\")\n    \n    # 入力検証\n    assert isinstance(full_name, str), \"full_name must be a string\"\n    assert len(full_name.strip()) > 0, \"full_name cannot be empty\"\n    assert isinstance(capitalize, bool), \"capitalize flag must be a boolean\"\n    \n    parts = full_name.split()\n    print(f\"Name split into parts: {parts}\")\n    \n    if capitalize:\n        parts = [p.capitalize() for p in parts]\n        print(f\"Capitalized parts: {parts}\")\n    \n    result = ' '.join(parts)\n    print(f\"Final formatted name: '{result}'\")\n    \n    return result", "test_cases": {"success": [{"input": ["'john doe'", "True"], "expected_output": "'John Doe'"}, {"input": ["'JANE SMITH'", "True"], "expected_output": "'Jane Smith'"}, {"input": ["'robert johnson'", "False"], "expected_output": "'robert johnson'"}], "failure": [{"input": ["123", "True"], "expected_exception": "AssertionError", "expected_message_part": "full_name must be a string"}, {"input": ["''", "True"], "expected_exception": "AssertionError", "expected_message_part": "full_name cannot be empty"}, {"input": ["'John Doe'", "'yes'"], "expected_exception": "AssertionError", "expected_message_part": "capitalize flag must be a boolean"}]}}
{"description": "辞書操作を行う関数では、入力辞書の存在確認、キーの有無、値の型チェックが重要です。また、デフォルト値や省略可能なパラメータを持つ関数では、それらの正しい使用方法を確認するためのアサーションが有効です。この例では複数の条件をチェックし、辞書処理の各ステップをデバッグプリントで追跡しています。", "keywords": ["dict", "dict.get", "dict.items", "dict.keys", "dict.values", "default"], "code_before": "def get_config_value(config, key, default=None, required=False):\n    if required and key not in config:\n        raise KeyError(f\"Required key '{key}' not found in config\")\n    return config.get(key, default)", "code_after": "def get_config_value(config, key, default=None, required=False):\n    print(f\"Getting config value: key='{key}', default={default}, required={required}\")\n    \n    # 入力検証\n    assert isinstance(config, dict), \"config must be a dictionary\"\n    assert isinstance(key, str), \"key must be a string\"\n    assert isinstance(required, bool), \"required flag must be a boolean\"\n    \n    print(f\"Config contains {len(config)} items: {list(config.keys())}\")\n    \n    if required:\n        assert key in config, f\"Required key '{key}' not found in config\"\n        print(f\"Required key '{key}' found in config\")\n    \n    result = config.get(key, default)\n    print(f\"Retrieved value for key '{key}': {result} (type: {type(result).__name__})\")\n    \n    return result", "test_cases": {"success": [{"input": ["{'host': 'localhost', 'port': 8080}", "'host'", "None", "False"], "expected_output": "'localhost'"}, {"input": ["{'debug': True}", "'timeout'", "30", "False"], "expected_output": "30"}, {"input": ["{'user': 'admin', 'password': 'secret'}", "'user'", "None", "True"], "expected_output": "'admin'"}], "failure": [{"input": ["'not a dict'", "'key'", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "config must be a dictionary"}, {"input": ["{}", "123", "None", "False"], "expected_exception": "AssertionError", "expected_message_part": "key must be a string"}, {"input": ["{}", "'key'", "None", "'not a bool'"], "expected_exception": "AssertionError", "expected_message_part": "required flag must be a boolean"}, {"input": ["{}", "'key'", "None", "True"], "expected_exception": "AssertionError", "expected_message_part": "Required key 'key' not found in config"}]}}
{"description": "数値計算を行う関数では、入力値の型検証だけでなく、値の範囲チェックや計算過程の追跡が重要です。特に除算やルート計算など、特定の条件で例外が発生する操作では、事前条件をアサーションでチェックすることで、より明確なエラーメッセージを提供できます。", "keywords": ["math", "division", "range", "sqrt", "float", "int"], "code_before": "def calculate_discount(price, discount_percent):\n    discount = price * (discount_percent / 100)\n    return price - discount", "code_after": "def calculate_discount(price, discount_percent):\n    print(f\"Calculating discount: price=${price}, discount={discount_percent}%\")\n    \n    # 入力検証\n    assert isinstance(price, (int, float)), \"Price must be a number\"\n    assert price >= 0, \"Price cannot be negative\"\n    assert isinstance(discount_percent, (int, float)), \"Discount percentage must be a number\"\n    assert 0 <= discount_percent <= 100, \"Discount percentage must be between 0 and 100\"\n    \n    discount = price * (discount_percent / 100)\n    print(f\"Calculated discount amount: ${discount:.2f}\")\n    \n    final_price = price - discount\n    print(f\"Final price after discount: ${final_price:.2f}\")\n    \n    return final_price", "test_cases": {"success": [{"input": ["100", "20"], "expected_output": "80.0"}, {"input": ["50.5", "10"], "expected_output": "45.45"}, {"input": ["200", "0"], "expected_output": "200.0"}], "failure": [{"input": ["'100'", "20"], "expected_exception": "AssertionError", "expected_message_part": "Price must be a number"}, {"input": ["-50", "10"], "expected_exception": "AssertionError", "expected_message_part": "Price cannot be negative"}, {"input": ["100", "'20'"], "expected_exception": "AssertionError", "expected_message_part": "Discount percentage must be a number"}, {"input": ["100", "120"], "expected_exception": "AssertionError", "expected_message_part": "Discount percentage must be between 0 and 100"}]}}
{"description": "ファイル操作関数では、ファイルパスの検証、ファイルの存在確認、操作結果の記録が重要です。この例では、ファイルの読み込み処理に対して、パス検証と例外処理の周辺にデバッグプリントを追加し、実行状況と潜在的な問題を追跡できるようにしています。", "keywords": ["file", "open", "read", "path", "os.path", "exception"], "code_before": "def read_file_content(filepath):\n    with open(filepath, 'r') as file:\n        content = file.read()\n    return content", "code_after": "import os\n\ndef read_file_content(filepath):\n    print(f\"Attempting to read file: {filepath}\")\n    \n    # 入力検証\n    assert isinstance(filepath, str), \"Filepath must be a string\"\n    assert len(filepath.strip()) > 0, \"Filepath cannot be empty\"\n    assert os.path.exists(filepath), f\"File does not exist: {filepath}\"\n    assert os.path.isfile(filepath), f\"Path is not a file: {filepath}\"\n    \n    try:\n        print(f\"Opening file in read mode\")\n        with open(filepath, 'r') as file:\n            content = file.read()\n            content_preview = content[:50] + '...' if len(content) > 50 else content\n            print(f\"Successfully read {len(content)} characters from file\")\n            print(f\"Content preview: {content_preview}\")\n        return content\n    except Exception as e:\n        print(f\"Error reading file: {e}\")\n        raise", "test_cases": {"success": [{"input": ["'sample.txt'"], "expected_output": "'This is a sample text file content.'"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Filepath must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "Filepath cannot be empty"}, {"input": ["'nonexistent_file.txt'"], "expected_exception": "AssertionError", "expected_message_part": "File does not exist"}, {"input": ["'/'"], "expected_exception": "AssertionError", "expected_message_part": "Path is not a file"}]}}
{"description": "数値の配列に対して平均値を計算する関数です。アサーションで引数がリストであること、かつ要素が数値型であることを確認し、デバッグプリントで処理の流れと計算結果を追跡できるようにしています。入力配列が空の場合は特別に処理することも保証しています。", "keywords": ["list", "average", "assertion", "numeric", "empty list"], "code_before": "def calculate_average(numbers):\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)", "code_after": "def calculate_average(numbers):\n    print(f\"開始: calculate_average(numbers={numbers})\")\n    \n    # 引数の検証\n    assert isinstance(numbers, list), \"引数はリストである必要があります\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"リストの全ての要素は数値である必要があります\"\n    \n    if not numbers:\n        print(f\"空のリストが渡されました。0を返します。\")\n        return 0\n    \n    total = sum(numbers)\n    length = len(numbers)\n    average = total / length\n    \n    print(f\"合計: {total}, 要素数: {length}, 平均値: {average}\")\n    print(f\"終了: calculate_average -> {average}\")\n    \n    return average", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "3.0"}, {"input": ["[10.5, 20.5]"], "expected_output": "15.5"}, {"input": ["[]"], "expected_output": "0"}], "failure": [{"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "引数はリストである必要があります"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "リストの全ての要素は数値である必要があります"}]}}
{"description": "ユーザー情報を辞書から取得する関数です。アサーションでユーザーIDの型チェックと辞書の存在チェックを行い、デバッグプリントでメソッドの開始・終了と取得結果を記録しています。このパターンは特に外部リソースやデータベースからの情報取得関数に適しています。", "keywords": ["dict", "get", "user", "validation", "None check"], "code_before": "def get_user_info(user_id, users_db):\n    if user_id in users_db:\n        return users_db[user_id]\n    return None", "code_after": "def get_user_info(user_id, users_db):\n    print(f\"開始: get_user_info(user_id={user_id})\")\n    \n    # 引数の検証\n    assert isinstance(user_id, (int, str)), \"ユーザーIDは整数または文字列である必要があります\"\n    assert isinstance(users_db, dict), \"ユーザーデータベースは辞書である必要があります\"\n    \n    if user_id in users_db:\n        user_info = users_db[user_id]\n        print(f\"ユーザー情報が見つかりました: {user_info}\")\n        print(f\"終了: get_user_info -> ユーザー情報を返します\")\n        return user_info\n    \n    print(f\"ユーザーID {user_id} に対応する情報が見つかりませんでした\")\n    print(f\"終了: get_user_info -> None を返します\")\n    return None", "test_cases": {"success": [{"input": ["1", "{1: {'name': 'Alice', 'age': 30}}"], "expected_output": "{'name': 'Alice', 'age': 30}"}, {"input": ["'user123'", "{'user123': {'name': 'Bob', 'age': 25}}"], "expected_output": "{'name': 'Bob', 'age': 25}"}, {"input": ["2", "{}"], "expected_output": "None"}], "failure": [{"input": ["[1, 2]", "{}"], "expected_exception": "AssertionError", "expected_message_part": "ユーザーIDは整数または文字列である必要があります"}, {"input": ["1", "[1, 2, 3]"], "expected_exception": "AssertionError", "expected_message_part": "ユーザーデータベースは辞書である必要があります"}]}}
{"description": "指定された範囲内でフィボナッチ数列を生成する関数です。アサーションで引数が正の整数であることを確認し、デバッグプリントで計算の進行状況と生成される数列を記録しています。再帰や繰り返し処理の進行状況を追跡するのに適したパターンです。", "keywords": ["fibonacci", "range", "sequence", "positive integer", "for loop"], "code_before": "def fibonacci_sequence(n):\n    sequence = [0, 1]\n    for i in range(2, n):\n        sequence.append(sequence[i-1] + sequence[i-2])\n    return sequence[:n]", "code_after": "def fibonacci_sequence(n):\n    print(f\"開始: fibonacci_sequence(n={n})\")\n    \n    # 引数の検証\n    assert isinstance(n, int), \"引数は整数である必要があります\"\n    assert n > 0, \"引数は正の整数である必要があります\"\n    \n    sequence = [0, 1]\n    print(f\"初期シーケンス: {sequence}\")\n    \n    if n <= 2:\n        result = sequence[:n]\n        print(f\"終了: fibonacci_sequence -> {result}\")\n        return result\n    \n    for i in range(2, n):\n        next_value = sequence[i-1] + sequence[i-2]\n        sequence.append(next_value)\n        print(f\"計算: fib({i}) = {sequence[i-1]} + {sequence[i-2]} = {next_value}\")\n    \n    print(f\"終了: fibonacci_sequence -> {sequence}\")\n    return sequence", "test_cases": {"success": [{"input": ["5"], "expected_output": "[0, 1, 1, 2, 3]"}, {"input": ["1"], "expected_output": "[0]"}, {"input": ["8"], "expected_output": "[0, 1, 1, 2, 3, 5, 8, 13]"}], "failure": [{"input": ["'5'"], "expected_exception": "AssertionError", "expected_message_part": "引数は整数である必要があります"}, {"input": ["0"], "expected_exception": "AssertionError", "expected_message_part": "引数は正の整数である必要があります"}, {"input": ["-3"], "expected_exception": "AssertionError", "expected_message_part": "引数は正の整数である必要があります"}]}}
{"description": "文字列を大文字に変換して特定の文字をカウントする関数です。アサーションで引数が文字列であることを確認し、デバッグプリントで変換前後の文字列と文字カウントの結果を記録しています。このパターンは文字列処理関数で特に有用です。", "keywords": ["string", "upper", "count", "character", "transformation"], "code_before": "def count_char_in_uppercase(text, char_to_count):\n    uppercase_text = text.upper()\n    count = uppercase_text.count(char_to_count.upper())\n    return count", "code_after": "def count_char_in_uppercase(text, char_to_count):\n    print(f\"開始: count_char_in_uppercase(text='{text}', char_to_count='{char_to_count}')\")\n    \n    # 引数の検証\n    assert isinstance(text, str), \"テキストは文字列である必要があります\"\n    assert isinstance(char_to_count, str), \"カウント対象の文字は文字列である必要があります\"\n    assert len(char_to_count) == 1, \"カウント対象は1文字である必要があります\"\n    \n    uppercase_text = text.upper()\n    print(f\"大文字変換後: '{uppercase_text}'\")\n    \n    char_to_count_upper = char_to_count.upper()\n    print(f\"カウント対象(大文字): '{char_to_count_upper}'\")\n    \n    count = uppercase_text.count(char_to_count_upper)\n    print(f\"文字 '{char_to_count_upper}' の出現回数: {count}\")\n    \n    print(f\"終了: count_char_in_uppercase -> {count}\")\n    return count", "test_cases": {"success": [{"input": ["'Hello World'", "'l'"], "expected_output": "3"}, {"input": ["'Python Programming'", "'p'"], "expected_output": "2"}, {"input": ["'abcABC'", "'a'"], "expected_output": "2"}, {"input": ["'No matches here'", "'z'"], "expected_output": "0"}], "failure": [{"input": ["123", "'a'"], "expected_exception": "AssertionError", "expected_message_part": "テキストは文字列である必要があります"}, {"input": ["'hello'", "123"], "expected_exception": "AssertionError", "expected_message_part": "カウント対象の文字は文字列である必要があります"}, {"input": ["'hello'", "'ab'"], "expected_exception": "AssertionError", "expected_message_part": "カウント対象は1文字である必要があります"}]}}
{"description": "数値リストの合計を計算する関数において、引数が有効なリストであることを確認するアサーションと、処理の各ステップをトレースするデバッグプリントを追加しています。このパターンは、特に繰り返し処理中の変数の状態を追跡する必要がある場合や、入力データの検証が重要な場合に有効です。", "keywords": ["list", "sum", "for loop", "validation", "numerical operations"], "code_before": "def sum_of_numbers(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total", "code_after": "def sum_of_numbers(numbers):\n    print(f\"Starting sum_of_numbers with input: {numbers}\")\n    \n    # Input validation\n    assert isinstance(numbers, list), f\"Input must be a list, got {type(numbers)}\"\n    assert all(isinstance(num, (int, float)) for num in numbers), \"All elements must be numbers\"\n    \n    total = 0\n    for i, num in enumerate(numbers):\n        total += num\n        print(f\"After adding element {i} ({num}): total = {total}\")\n    \n    print(f\"Returning final total: {total}\")\n    return total", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "15"}, {"input": ["[-10, 10, 5.5]"], "expected_output": "5.5"}, {"input": ["[]"], "expected_output": "0"}], "failure": [{"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a list"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}]}}
{"description": "文字列の単語数をカウントする関数に、入力が有効な文字列であることを確認するアサーションと、単語分割のプロセスを可視化するデバッグプリントを追加しています。このパターンは、テキスト処理関数の動作追跡や入力バリデーションに適しています。", "keywords": ["string", "split", "len", "text processing", "count"], "code_before": "def count_words(text):\n    words = text.split()\n    return len(words)", "code_after": "def count_words(text):\n    print(f\"count_words called with text: '{text}'\")\n    \n    # Validate input\n    assert isinstance(text, str), f\"Input must be a string, got {type(text)}\"\n    \n    # Process and debug\n    words = text.split()\n    print(f\"Text split into {len(words)} words: {words}\")\n    \n    result = len(words)\n    print(f\"Returning word count: {result}\")\n    return result", "test_cases": {"success": [{"input": ["'Hello world'"], "expected_output": "2"}, {"input": ["'The quick brown fox jumps over the lazy dog'"], "expected_output": "9"}, {"input": ["''"], "expected_output": "0"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a string"}]}}
{"description": "辞書から値を安全に取得する関数において、引数の型チェックを行うアサーションと、辞書操作の詳細を表示するデバッグプリントを追加しています。このパターンは、複数の条件分岐を持つ関数や、デフォルト値を使用する処理の流れを追跡するのに役立ちます。", "keywords": ["dict", "get", "default", "type checking", "key lookup"], "code_before": "def safe_get_value(dictionary, key, default=None):\n    if key in dictionary:\n        return dictionary[key]\n    return default", "code_after": "def safe_get_value(dictionary, key, default=None):\n    print(f\"safe_get_value called with key='{key}', default={default}\")\n    \n    # Validate dictionary input\n    assert isinstance(dictionary, dict), f\"First argument must be a dictionary, got {type(dictionary)}\"\n    \n    # Debug dictionary content\n    print(f\"Dictionary: {dictionary}\")\n    \n    if key in dictionary:\n        result = dictionary[key]\n        print(f\"Key '{key}' found. Returning value: {result}\")\n        return result\n    else:\n        print(f\"Key '{key}' not found. Returning default: {default}\")\n        return default", "test_cases": {"success": [{"input": ["{'a': 1, 'b': 2}", "'a'", "None"], "expected_output": "1"}, {"input": ["{'a': 1, 'b': 2}", "'c'", "0"], "expected_output": "0"}, {"input": ["{}", "'x'", "None"], "expected_output": "None"}], "failure": [{"input": ["'not a dict'", "'key'", "None"], "expected_exception": "AssertionError", "expected_message_part": "First argument must be a dictionary"}]}}
{"description": "指定された範囲内の数値をフィルタリングする関数に、引数の型と値の範囲をチェックするアサーションと、フィルタリングプロセスの詳細を表示するデバッグプリントを追加しています。このパターンは、複雑なフィルタリング条件を持つ関数や、入力と出力の対応関係を詳細に追跡したい場合に有効です。", "keywords": ["list comprehension", "filter", "range check", "validation", "min/max"], "code_before": "def filter_numbers_in_range(numbers, min_val, max_val):\n    return [num for num in numbers if min_val <= num <= max_val]", "code_after": "def filter_numbers_in_range(numbers, min_val, max_val):\n    print(f\"filter_numbers_in_range called with: numbers={numbers}, min={min_val}, max={max_val}\")\n    \n    # Validate inputs\n    assert isinstance(numbers, list), f\"'numbers' must be a list, got {type(numbers)}\"\n    assert all(isinstance(num, (int, float)) for num in numbers), \"All elements in 'numbers' must be numeric\"\n    assert isinstance(min_val, (int, float)), f\"'min_val' must be a number, got {type(min_val)}\"\n    assert isinstance(max_val, (int, float)), f\"'max_val' must be a number, got {type(max_val)}\"\n    assert min_val <= max_val, f\"'min_val' ({min_val}) must be less than or equal to 'max_val' ({max_val})\"\n    \n    # Filter and debug\n    result = []\n    for num in numbers:\n        if min_val <= num <= max_val:\n            result.append(num)\n            print(f\"Including {num} (within range)\")\n        else:\n            print(f\"Excluding {num} (outside range)\")\n    \n    print(f\"Filtered result: {result}\")\n    return result", "test_cases": {"success": [{"input": ["[1, 5, 10, 15, 20]", "5", "15"], "expected_output": "[5, 10, 15]"}, {"input": ["[-10, 0, 10, 20]", "-5", "5"], "expected_output": "[0]"}, {"input": ["[1, 2, 3]", "10", "20"], "expected_output": "[]"}], "failure": [{"input": ["'not a list'", "0", "10"], "expected_exception": "AssertionError", "expected_message_part": "'numbers' must be a list"}, {"input": ["[1, 2, '3']", "0", "10"], "expected_exception": "AssertionError", "expected_message_part": "All elements in 'numbers' must be numeric"}, {"input": ["[1, 2, 3]", "'0'", "10"], "expected_exception": "AssertionError", "expected_message_part": "'min_val' must be a number"}, {"input": ["[1, 2, 3]", "10", "5"], "expected_exception": "AssertionError", "expected_message_part": "'min_val' (10) must be less than or equal to 'max_val' (5)"}]}}
{"description": "二つの日付間の日数を計算する関数に、日付の形式と関係性を検証するアサーションと、計算プロセスをトレースするデバッグプリントを追加しています。このパターンは、日付操作やタイムスタンプを扱う関数の検証において特に有用です。また、複数の外部ライブラリを使用する関数のデバッグにも適しています。", "keywords": ["datetime", "date", "timedelta", "validation", "date parsing"], "code_before": "import datetime\n\ndef days_between_dates(start_date_str, end_date_str):\n    start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()\n    end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()\n    delta = end_date - start_date\n    return delta.days", "code_after": "import datetime\n\ndef days_between_dates(start_date_str, end_date_str):\n    print(f\"days_between_dates called with: start='{start_date_str}', end='{end_date_str}'\")\n    \n    # Validate inputs\n    assert isinstance(start_date_str, str), f\"start_date_str must be a string, got {type(start_date_str)}\"\n    assert isinstance(end_date_str, str), f\"end_date_str must be a string, got {type(end_date_str)}\"\n    \n    # Parse dates with try/except to provide better error messages\n    try:\n        start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()\n        print(f\"Parsed start_date: {start_date}\")\n    except ValueError as e:\n        raise AssertionError(f\"Invalid start date format: {e}\")\n    \n    try:\n        end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()\n        print(f\"Parsed end_date: {end_date}\")\n    except ValueError as e:\n        raise AssertionError(f\"Invalid end date format: {e}\")\n    \n    # Calculate difference\n    delta = end_date - start_date\n    result = delta.days\n    print(f\"Date difference: {result} days\")\n    \n    return result", "test_cases": {"success": [{"input": ["'2023-01-01'", "'2023-01-10'"], "expected_output": "9"}, {"input": ["'2023-05-15'", "'2023-05-15'"], "expected_output": "0"}, {"input": ["'2022-12-31'", "'2023-01-01'"], "expected_output": "1"}, {"input": ["'2023-01-10'", "'2023-01-01'"], "expected_output": "-9"}], "failure": [{"input": ["123", "'2023-01-10'"], "expected_exception": "AssertionError", "expected_message_part": "start_date_str must be a string"}, {"input": ["'2023-01-01'", "123"], "expected_exception": "AssertionError", "expected_message_part": "end_date_str must be a string"}, {"input": ["'01/01/2023'", "'2023-01-10'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid start date format"}, {"input": ["'2023-01-01'", "'2023/01/10'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid end date format"}]}}
{"description": "数値リストの平均値を計算する関数にアサーションとデバッグプリントを追加しました。入力が空リストでないこと、すべての要素が数値であることを検証します。処理の開始と終了、計算過程の主要な値をログ出力します。これは、数値データを扱う関数において前提条件の検証とデバッグトレースを導入するパターンとして有効です。", "keywords": ["list", "sum", "len", "数値計算", "平均値"], "code_before": "def calculate_average(numbers):\n    total = sum(numbers)\n    average = total / len(numbers)\n    return average", "code_after": "def calculate_average(numbers):\n    print(f\"計算開始: 入力リスト = {numbers}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), \"入力はリスト型である必要があります\"\n    assert len(numbers) > 0, \"空のリストは平均値を計算できません\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"すべての要素は数値である必要があります\"\n    \n    # 計算処理\n    total = sum(numbers)\n    print(f\"合計値: {total}\")\n    \n    average = total / len(numbers)\n    print(f\"計算完了: 平均値 = {average}\")\n    \n    return average", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "3.0"}, {"input": ["[10.5, 20.5, 30.5]"], "expected_output": "20.5"}], "failure": [{"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "空のリストは平均値を計算できません"}, {"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "入力はリスト型である必要があります"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "すべての要素は数値である必要があります"}]}}
{"description": "ユーザー名とパスワードによる認証関数にアサーションとデバッグプリントを追加しました。入力の型、文字列の長さ、パスワードの複雑さを検証し、処理の流れを追跡します。これは、セキュリティ関連の関数において入力バリデーションとデバッグを強化するパターンとして有効です。", "keywords": ["authenticate", "password", "validation", "セキュリティ", "if"], "code_before": "def authenticate_user(username, password):\n    if username == 'admin' and password == 'secure_pwd123':\n        return True\n    return False", "code_after": "def authenticate_user(username, password):\n    print(f\"認証開始: ユーザー名 = {username}\")\n    \n    # 入力検証\n    assert isinstance(username, str), \"ユーザー名は文字列である必要があります\"\n    assert isinstance(password, str), \"パスワードは文字列である必要があります\"\n    assert len(username) >= 3, \"ユーザー名は3文字以上である必要があります\"\n    assert len(password) >= 8, \"パスワードは8文字以上である必要があります\"\n    \n    # パスワード複雑さの検証\n    has_digit = any(c.isdigit() for c in password)\n    has_alpha = any(c.isalpha() for c in password)\n    assert has_digit and has_alpha, \"パスワードは英字と数字を含む必要があります\"\n    \n    # 認証処理\n    is_authenticated = (username == 'admin' and password == 'secure_pwd123')\n    print(f\"認証結果: {is_authenticated}\")\n    \n    return is_authenticated", "test_cases": {"success": [{"input": ["'admin'", "'secure_pwd123'"], "expected_output": "True"}, {"input": ["'user123'", "'password123'"], "expected_output": "False"}], "failure": [{"input": ["123", "'secure_pwd123'"], "expected_exception": "AssertionError", "expected_message_part": "ユーザー名は文字列である必要があります"}, {"input": ["'ab'", "'secure_pwd123'"], "expected_exception": "AssertionError", "expected_message_part": "ユーザー名は3文字以上である必要があります"}, {"input": ["'admin'", "'short'"], "expected_exception": "AssertionError", "expected_message_part": "パスワードは8文字以上である必要があります"}, {"input": ["'admin'", "'onlyletters'"], "expected_exception": "AssertionError", "expected_message_part": "パスワードは英字と数字を含む必要があります"}]}}
{"description": "ファイルパスから拡張子を抽出する単純な関数にデバッグプリントのみを追加しました。関数の処理が単純なため、アサーションは不要ですが、プログラムの流れをトレースしやすくするためにデバッグプリントを活用しています。これは、短いユーティリティ関数のデバッグトレースを強化するパターンとして有効です。", "keywords": ["string", "split", "ファイル操作", "パス解析"], "code_before": "def get_file_extension(filepath):\n    parts = filepath.split('.')\n    if len(parts) > 1:\n        return parts[-1]\n    return ''", "code_after": "def get_file_extension(filepath):\n    print(f\"ファイル拡張子の抽出開始: {filepath}\")\n    \n    parts = filepath.split('.')\n    print(f\"分割結果: {parts}\")\n    \n    if len(parts) > 1:\n        extension = parts[-1]\n        print(f\"拡張子が見つかりました: {extension}\")\n        return extension\n    \n    print(\"拡張子が見つかりませんでした\")\n    return ''", "test_cases": {"success": [{"input": ["'document.txt'"], "expected_output": "'txt'"}, {"input": ["'image.jpg.png'"], "expected_output": "'png'"}, {"input": ["'file_without_extension'"], "expected_output": "''"}], "failure": []}}
{"description": "辞書から値を取得し、デフォルト値を返す関数にアサーションとデバッグプリントを追加しました。入力の型とキーの存在を検証し、処理の流れを追跡します。これは、辞書操作を行う関数において前提条件の検証とデバッグを強化するパターンとして有効です。", "keywords": ["dict", "get", "default", "キー検索"], "code_before": "def get_value_from_dict(data_dict, key, default=None):\n    if key in data_dict:\n        return data_dict[key]\n    return default", "code_after": "def get_value_from_dict(data_dict, key, default=None):\n    print(f\"辞書からの値取得開始: キー = {key}, デフォルト値 = {default}\")\n    \n    # 入力検証\n    assert isinstance(data_dict, dict), \"第1引数は辞書型である必要があります\"\n    assert key is not None, \"キーはNoneであってはなりません\"\n    \n    # キー検索処理\n    if key in data_dict:\n        value = data_dict[key]\n        print(f\"キーが見つかりました: {key} => {value}\")\n        return value\n    \n    print(f\"キーが見つかりませんでした: デフォルト値 {default} を返します\")\n    return default", "test_cases": {"success": [{"input": ["{\"name\": \"John\", \"age\": 30}", "'name'", "None"], "expected_output": "'John'"}, {"input": ["{\"name\": \"John\", \"age\": 30}", "'email'", "'unknown'"], "expected_output": "'unknown'"}], "failure": [{"input": ["'not a dict'", "'key'", "None"], "expected_exception": "AssertionError", "expected_message_part": "第1引数は辞書型である必要があります"}, {"input": ["{}", "None", "'default'"], "expected_exception": "AssertionError", "expected_message_part": "キーはNoneであってはなりません"}]}}
{"description": "指定された範囲内の整数をソートする関数にアサーションとデバッグプリントを追加しました。入力値の型と範囲を厳密に検証し、処理の各ステップの状態を追跡します。これは、数値処理を行う関数において境界条件のチェックとデバッグを強化するパターンとして有効です。", "keywords": ["sort", "range", "list", "数値範囲", "ソート"], "code_before": "def sort_numbers_in_range(numbers, min_val, max_val):\n    filtered = [n for n in numbers if min_val <= n <= max_val]\n    return sorted(filtered)", "code_after": "def sort_numbers_in_range(numbers, min_val, max_val):\n    print(f\"範囲内の数値ソート開始: 対象リスト = {numbers}, 最小値 = {min_val}, 最大値 = {max_val}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), \"第1引数はリスト型である必要があります\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"リストの全要素は数値である必要があります\"\n    assert isinstance(min_val, (int, float)), \"最小値は数値型である必要があります\"\n    assert isinstance(max_val, (int, float)), \"最大値は数値型である必要があります\"\n    assert min_val <= max_val, \"最小値は最大値以下である必要があります\"\n    \n    # フィルタリング処理\n    filtered = [n for n in numbers if min_val <= n <= max_val]\n    print(f\"フィルタリング結果: {filtered}\")\n    \n    # ソート処理\n    result = sorted(filtered)\n    print(f\"ソート完了: {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["[5, 2, 8, 1, 10]", "1", "5"], "expected_output": "[1, 2, 5]"}, {"input": ["[100, 50, 25, 75]", "30", "80"], "expected_output": "[50, 75]"}, {"input": ["[1, 2, 3]", "10", "20"], "expected_output": "[]"}], "failure": [{"input": ["'not a list'", "1", "5"], "expected_exception": "AssertionError", "expected_message_part": "第1引数はリスト型である必要があります"}, {"input": ["[1, 2, '3', 4]", "1", "5"], "expected_exception": "AssertionError", "expected_message_part": "リストの全要素は数値である必要があります"}, {"input": ["[1, 2, 3]", "'1'", "5"], "expected_exception": "AssertionError", "expected_message_part": "最小値は数値型である必要があります"}, {"input": ["[1, 2, 3]", "5", "1"], "expected_exception": "AssertionError", "expected_message_part": "最小値は最大値以下である必要があります"}]}}
