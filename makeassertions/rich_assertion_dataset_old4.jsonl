{"title": "リスト内の数値を合計する関数", "description": "数値リストを扱う関数において、入力検証とデバッグ情報を充実させるためのパターンです。入力が適切なリストであること、各要素が数値であることを検証し、処理中の状態を追跡できるようにします。このパターンは、データ処理やリスト操作を行う関数で特に有効です。", "keywords": ["list", "sum", "assert", "iteration", "numeric validation"], "code_before": "def sum_numbers(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total", "code_after": "def sum_numbers(numbers):\n    print(f\"[DEBUG] sum_numbers関数を開始: 入力={numbers}\")\n    \n    # 入力検証\n    assert isinstance(numbers, list), f\"入力はリストである必要があります。実際の型: {type(numbers)}\"\n    assert len(numbers) > 0, \"空のリストは許可されていません\"\n    \n    total = 0\n    print(f\"[DEBUG] 合計の初期値: {total}\")\n    \n    for i, num in enumerate(numbers):\n        assert isinstance(num, (int, float)), f\"リストの要素 {i} は数値である必要があります。実際の値: {num}, 型: {type(num)}\"\n        total += num\n        print(f\"[DEBUG] 要素 {i}: {num} を追加後の合計: {total}\")\n    \n    print(f\"[DEBUG] sum_numbers関数を終了: 結果={total}\")\n    return total", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "15"}, {"input": ["[10.5, 20.3, 30.2]"], "expected_output": "61.0"}, {"input": ["[0, -5, 10]"], "expected_output": "5"}], "failure": [{"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "入力はリストである必要があります"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "空のリストは許可されていません"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "リストの要素 2 は数値である必要があります"}]}}
{"title": "辞書からの安全な値取得関数", "description": "辞書操作において、キーの存在確認とデフォルト値処理を組み合わせたパターンです。このパターンは、辞書から値を取得する際に発生しうるKeyErrorを防ぎ、指定したキーが存在しない場合にデフォルト値を返すことで、プログラムの堅牢性を高めます。入力検証とプロセス追跡のためのデバッグプリントを豊富に含めることで、辞書操作の動作を詳細に把握できます。", "keywords": ["dict", "get", "default", "key validation", "defensive programming"], "code_before": "def get_value(data, key, default=None):\n    if key in data:\n        return data[key]\n    return default", "code_after": "def get_value(data, key, default=None):\n    print(f\"[DEBUG] get_value関数を開始: data={data}, key={key}, default={default}\")\n    \n    # 入力検証\n    assert data is not None, \"データはNoneであってはなりません\"\n    assert isinstance(data, dict), f\"dataは辞書である必要があります。実際の型: {type(data)}\"\n    \n    # キーの型をチェック（Noneでないことと、ハッシュ可能であること）\n    assert key is not None, \"キーはNoneであってはなりません\"\n    try:\n        hash(key)\n    except TypeError:\n        assert False, f\"キーはハッシュ可能である必要があります。実際の値: {key}, 型: {type(key)}\"\n    \n    print(f\"[DEBUG] キー '{key}' の存在確認を行います\")\n    if key in data:\n        value = data[key]\n        print(f\"[DEBUG] キー '{key}' が存在します。値: {value}\")\n        return value\n    else:\n        print(f\"[DEBUG] キー '{key}' が存在しません。デフォルト値 {default} を返します\")\n        return default", "test_cases": {"success": [{"input": ["{\"name\": \"Alice\", \"age\": 30}", "\"name\"", "None"], "expected_output": "\"Alice\""}, {"input": ["{\"name\": \"Alice\", \"age\": 30}", "\"email\"", "\"unknown@example.com\""], "expected_output": "\"unknown@example.com\""}, {"input": ["{1: \"one\", 2: \"two\"}", "1", "\"default\""], "expected_output": "\"one\""}], "failure": [{"input": ["None", "\"key\"", "\"default\""], "expected_exception": "AssertionError", "expected_message_part": "データはNoneであってはなりません"}, {"input": ["[1, 2, 3]", "\"key\"", "\"default\""], "expected_exception": "AssertionError", "expected_message_part": "dataは辞書である必要があります"}, {"input": ["{\"name\": \"Alice\"}", "None", "\"default\""], "expected_exception": "AssertionError", "expected_message_part": "キーはNoneであってはなりません"}, {"input": ["{\"name\": \"Alice\"}", "[1, 2]", "\"default\""], "expected_exception": "AssertionError", "expected_message_part": "キーはハッシュ可能である必要があります"}]}}
{"title": "文字列の正規化関数", "description": "文字列を特定の形式に正規化する関数のためのデバッグとアサーションパターンです。このパターンは、入力文字列の検証（空でないこと、タイプチェック）、処理の各ステップでの状態確認、文字列変換の適切な適用を保証します。テキスト処理や文字列操作を伴う関数で特に有効です。", "keywords": ["string", "normalize", "strip", "lower", "text processing"], "code_before": "def normalize_text(text):\n    text = text.strip()\n    text = text.lower()\n    text = ' '.join(text.split())\n    return text", "code_after": "def normalize_text(text):\n    print(f\"[DEBUG] normalize_text関数を開始: text='{text}'\")\n    \n    # 入力検証\n    assert text is not None, \"入力テキストはNoneであってはなりません\"\n    assert isinstance(text, str), f\"入力は文字列である必要があります。実際の型: {type(text)}\"\n    \n    # 1. 先頭と末尾の空白を削除\n    text_stripped = text.strip()\n    print(f\"[DEBUG] 空白削除後: '{text_stripped}'\")\n    \n    # 2. 小文字に変換\n    text_lower = text_stripped.lower()\n    print(f\"[DEBUG] 小文字変換後: '{text_lower}'\")\n    \n    # 3. 連続する空白を単一の空白に置換\n    words = text_lower.split()\n    print(f\"[DEBUG] 分割された単語: {words}\")\n    \n    normalized = ' '.join(words)\n    print(f\"[DEBUG] 正規化後のテキスト: '{normalized}'\")\n    \n    # 結果の検証\n    assert normalized.strip() == normalized, \"正規化後のテキストには先頭または末尾の空白が含まれてはなりません\"\n    assert normalized.lower() == normalized, \"正規化後のテキストはすべて小文字でなければなりません\"\n    assert '  ' not in normalized, \"正規化後のテキストには連続する空白が含まれてはなりません\"\n    \n    print(f\"[DEBUG] normalize_text関数を終了: 結果='{normalized}'\")\n    return normalized", "test_cases": {"success": [{"input": ["\"  Hello   World  \""], "expected_output": "\"hello world\""}, {"input": ["\"MIXED   case   TEXT\""], "expected_output": "\"mixed case text\""}, {"input": ["\"single\""], "expected_output": "\"single\""}], "failure": [{"input": ["None"], "expected_exception": "AssertionError", "expected_message_part": "入力テキストはNoneであってはなりません"}, {"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "入力は文字列である必要があります"}]}}
{"title": "リスト内の特定要素をフィルタリングする関数", "description": "フィルタリング処理では入力リストの型チェックと結果の整合性検証が重要です。このパターンは、リスト操作を行う関数において、入力検証と処理結果の検証を行いたい場合に有効です。デバッグプリントでは中間処理の状態を確認し、アサーションで入力と出力の条件を保証しています。", "keywords": ["filter", "list", "condition", "comprehension", "validation"], "code_before": "def filter_positive_numbers(numbers):\n    return [num for num in numbers if num > 0]", "code_after": "def filter_positive_numbers(numbers):\n    # 入力の型をチェック\n    assert isinstance(numbers, list), \"Input must be a list\"\n    \n    print(f\"DEBUG: Processing list with {len(numbers)} elements: {numbers}\")\n    \n    # リスト内の全要素が数値型かチェック\n    for i, num in enumerate(numbers):\n        assert isinstance(num, (int, float)), f\"Element at index {i} is not a number: {type(num)}\"\n    \n    # フィルタリング処理を実行\n    result = [num for num in numbers if num > 0]\n    \n    print(f\"DEBUG: Filtered {len(numbers) - len(result)} negative or zero elements\")\n    print(f\"DEBUG: Result contains {len(result)} positive numbers: {result}\")\n    \n    # 結果の検証: 全ての要素が正の数であることを確認\n    assert all(num > 0 for num in result), \"Filtering failed: result contains non-positive numbers\"\n    \n    # 結果の検証: 入力リストの正の数がすべて結果に含まれていることを確認\n    original_positives = [num for num in numbers if num > 0]\n    assert sorted(result) == sorted(original_positives), \"Filtering failed: missing some positive numbers\"\n    \n    return result", "test_cases": {"success": [{"input": ["[1, -2, 3, 0, 5]"], "expected_output": "[1, 3, 5]"}, {"input": ["[-10, -5, 0]"], "expected_output": "[]"}, {"input": ["[5.5, 10, -3.3, 7]"], "expected_output": "[5.5, 10, 7]"}], "failure": [{"input": ["'not a list'"], "expected_exception": "AssertionError", "expected_message_part": "Input must be a list"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "is not a number"}]}}
{"title": "ファイルパスの検証と正規化を行う関数", "description": "ファイルパス処理では、入力検証や結果の整合性確認が重要です。このパターンは、ファイルパスを操作する関数で入力パスの存在確認や正規化処理の検証を行う場合に有効です。アサーションで入力の型や形式をチェックし、デバッグプリントで変換過程を追跡しています。", "keywords": ["path", "file", "normalize", "os.path", "validation"], "code_before": "import os\n\ndef normalize_file_path(file_path):\n    abs_path = os.path.abspath(file_path)\n    return abs_path", "code_after": "import os\n\ndef normalize_file_path(file_path):\n    # 入力の型をチェック\n    assert isinstance(file_path, str), f\"File path must be a string, got {type(file_path)}\"\n    \n    # 空のパスではないことを確認\n    assert file_path.strip(), \"File path cannot be empty\"\n    \n    print(f\"DEBUG: Input file path: '{file_path}'\")\n    \n    # 絶対パスに変換\n    abs_path = os.path.abspath(file_path)\n    print(f\"DEBUG: Converted to absolute path: '{abs_path}'\")\n    \n    # 正規化された結果が文字列であることを確認\n    assert isinstance(abs_path, str), f\"Normalized path must be a string, got {type(abs_path)}\"\n    \n    # 結果が空でないことを確認\n    assert abs_path.strip(), \"Normalized path cannot be empty\"\n    \n    # 元のパスと比較して本当に正規化されたことを確認\n    if os.path.isabs(file_path):\n        print(f\"DEBUG: Original path was already absolute\")\n        # 絶対パスから正規化された場合、少なくとも同じ長さか短くなるはず\n        norm_path = os.path.normpath(file_path)\n        print(f\"DEBUG: Normalized original path: '{norm_path}'\")\n        assert len(abs_path) <= len(norm_path) or abs_path == norm_path, \"Path normalization failed\"\n    else:\n        print(f\"DEBUG: Converted relative path to absolute\")\n    \n    return abs_path", "test_cases": {"success": [{"input": ["'./test/file.txt'"], "expected_output": "os.path.abspath('./test/file.txt')"}, {"input": ["'../documents/report.pdf'"], "expected_output": "os.path.abspath('../documents/report.pdf')"}, {"input": ["'/usr/local/bin/python'"], "expected_output": "'/usr/local/bin/python'"}], "failure": [{"input": ["123"], "expected_exception": "AssertionError", "expected_message_part": "File path must be a string"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "File path cannot be empty"}]}}
{"title": "日付の検証と書式変換を行う関数", "description": "日付処理では、入力形式の検証と変換結果の妥当性確認が重要です。このパターンは、日付文字列を操作する関数において入力の形式チェックや出力形式の検証を行う場合に有効です。デバッグプリントで変換過程を追跡し、アサーションで日付形式の制約を保証しています。", "keywords": ["date", "format", "validation", "datetime", "strptime", "strftime"], "code_before": "from datetime import datetime\n\ndef format_date(date_string, input_format='%Y-%m-%d', output_format='%d/%m/%Y'):\n    date_obj = datetime.strptime(date_string, input_format)\n    return date_obj.strftime(output_format)", "code_after": "from datetime import datetime\nimport re\n\ndef format_date(date_string, input_format='%Y-%m-%d', output_format='%d/%m/%Y'):\n    # 入力の型をチェック\n    assert isinstance(date_string, str), f\"Date string must be a string, got {type(date_string)}\"\n    assert isinstance(input_format, str), f\"Input format must be a string, got {type(input_format)}\"\n    assert isinstance(output_format, str), f\"Output format must be a string, got {type(output_format)}\"\n    \n    # 入力文字列が空でないことを確認\n    assert date_string.strip(), \"Date string cannot be empty\"\n    \n    # フォーマット文字列が空でないことを確認\n    assert input_format.strip(), \"Input format cannot be empty\"\n    assert output_format.strip(), \"Output format cannot be empty\"\n    \n    print(f\"DEBUG: Input date string: '{date_string}'\")\n    print(f\"DEBUG: Input format: '{input_format}'\")\n    print(f\"DEBUG: Output format: '{output_format}'\")\n    \n    try:\n        # 日付オブジェクトに変換\n        date_obj = datetime.strptime(date_string, input_format)\n        print(f\"DEBUG: Parsed date object: {date_obj}\")\n        \n        # 結果の文字列を生成\n        result = date_obj.strftime(output_format)\n        print(f\"DEBUG: Formatted output: '{result}'\")\n        \n        # 結果が空でないことを確認\n        assert result.strip(), \"Formatted date cannot be empty\"\n        \n        # 結果が出力フォーマットに従っていることを確認\n        # 日付から戻した文字列を再解析して同じ日付になるか確認\n        try:\n            back_to_date = datetime.strptime(result, output_format)\n            print(f\"DEBUG: Re-parsed result: {back_to_date}\")\n            \n            # 年月日が一致するか確認（時間部分は省略）\n            assert date_obj.year == back_to_date.year, \"Year mismatch in reformatting\"\n            assert date_obj.month == back_to_date.month, \"Month mismatch in reformatting\"\n            assert date_obj.day == back_to_date.day, \"Day mismatch in reformatting\"\n        except ValueError as e:\n            print(f\"DEBUG: Warning - Could not validate output format: {e}\")\n        \n        return result\n        \n    except ValueError as e:\n        print(f\"DEBUG: Error parsing date: {e}\")\n        raise AssertionError(f\"Invalid date string '{date_string}' for format '{input_format}': {e}\")", "test_cases": {"success": [{"input": ["'2023-01-15'", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_output": "'15/01/2023'"}, {"input": ["'01/15/2023'", "'%m/%d/%Y'", "'%Y-%m-%d'"], "expected_output": "'2023-01-15'"}, {"input": ["'2023-01-15 14:30:00'", "'%Y-%m-%d %H:%M:%S'", "'%d %b, %Y'"], "expected_output": "'15 Jan, 2023'"}], "failure": [{"input": ["'2023/01/15'", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Invalid date string"}, {"input": ["''", "'%Y-%m-%d'", "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Date string cannot be empty"}, {"input": ["'2023-01-15'", "''", "'%d/%m/%Y'"], "expected_exception": "AssertionError", "expected_message_part": "Input format cannot be empty"}]}}
{"title": "メールアドレスの検証関数", "description": "メールアドレスの基本的な検証を行う関数に、入力値の型チェック、形式チェック、各処理段階での値の確認などのアサーションとデバッグプリントを追加しています。入力値の検証が重要な関数では、早期に不正な入力を検出するためのアサーション、そして処理の流れを追跡するためのデバッグプリントが有効です。", "keywords": ["string", "validation", "regex", "email", "assert", "isinstance", "print"], "code_before": "def validate_email(email):\n    if not email or '@' not in email:\n        return False\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    username, domain = parts\n    if not username or not domain:\n        return False\n    if '.' not in domain:\n        return False\n    return True", "code_after": "def validate_email(email):\n    print(f\"DEBUG: Validating email: {email!r}\")\n    \n    # 入力が文字列かチェック\n    assert isinstance(email, str), f\"Email must be a string, got {type(email).__name__}\"\n    \n    # 空文字列でないことをチェック\n    assert email, \"Email cannot be empty\"\n    \n    print(f\"DEBUG: Checking if '@' is in email\")\n    if '@' not in email:\n        print(f\"DEBUG: '@' not found in email\")\n        return False\n    \n    print(f\"DEBUG: Splitting email into parts at '@'\")\n    parts = email.split('@')\n    print(f\"DEBUG: Parts after split: {parts}\")\n    \n    assert len(parts) > 0, \"Unexpected split result: empty parts list\"\n    \n    if len(parts) != 2:\n        print(f\"DEBUG: Invalid number of '@' characters: {len(parts)-1}\")\n        return False\n    \n    username, domain = parts\n    print(f\"DEBUG: Username: {username!r}, Domain: {domain!r}\")\n    \n    if not username:\n        print(\"DEBUG: Username is empty\")\n        return False\n    \n    if not domain:\n        print(\"DEBUG: Domain is empty\")\n        return False\n    \n    print(f\"DEBUG: Checking if '.' is in domain\")\n    if '.' not in domain:\n        print(f\"DEBUG: '.' not found in domain\")\n        return False\n    \n    # ドメイン部分が少なくとも1つのドットを含み、最後のセグメントが空でないことを確認\n    domain_parts = domain.split('.')\n    print(f\"DEBUG: Domain parts: {domain_parts}\")\n    assert len(domain_parts) >= 2, \"Domain must have at least one dot with non-empty parts\"\n    assert all(domain_parts), \"All domain parts must be non-empty\"\n    \n    print(\"DEBUG: Email validation successful\")\n    return True", "test_cases": {"success": [{"input": ["'user@example.com'"], "expected_output": "True"}, {"input": ["'john.doe@company.co.jp'"], "expected_output": "True"}], "failure": [{"input": [123], "expected_exception": "AssertionError", "expected_message_part": "Email must be a string, got int"}, {"input": ["''"], "expected_exception": "AssertionError", "expected_message_part": "Email cannot be empty"}, {"input": ["'domain.com'"], "expected_output": "False"}, {"input": ["'user@'"], "expected_output": "False"}, {"input": ["'user@domain'"], "expected_output": "False"}]}}
{"title": "URLパラメータの解析関数", "description": "URL文字列からクエリパラメータを抽出して辞書に変換する関数です。入力の検証、文字列操作の各段階での中間値の確認、想定外の形式への対応などをアサーションとデバッグプリントで強化しています。複数のステップに分かれる文字列処理では、各処理段階の値を追跡するデバッグプリントが問題の早期発見に役立ちます。", "keywords": ["string", "parsing", "url", "query parameters", "split", "dict comprehension", "isinstance"], "code_before": "def parse_url_params(url):\n    if '?' not in url:\n        return {}\n    query_string = url.split('?')[1]\n    if not query_string:\n        return {}\n    params = {}\n    for param in query_string.split('&'):\n        if '=' in param:\n            key, value = param.split('=', 1)\n            params[key] = value\n    return params", "code_after": "def parse_url_params(url):\n    print(f\"DEBUG: Parsing URL: {url!r}\")\n    \n    # 入力が文字列かチェック\n    assert isinstance(url, str), f\"URL must be a string, got {type(url).__name__}\"\n    \n    print(f\"DEBUG: Checking if '?' exists in URL\")\n    if '?' not in url:\n        print(\"DEBUG: No query parameters found in URL\")\n        return {}\n    \n    print(f\"DEBUG: Splitting URL at '?'\")\n    parts = url.split('?')\n    assert len(parts) >= 2, \"Unexpected split result after '?' character\"\n    \n    query_string = parts[1]\n    print(f\"DEBUG: Query string: {query_string!r}\")\n    \n    if not query_string:\n        print(\"DEBUG: Query string is empty\")\n        return {}\n    \n    params = {}\n    print(f\"DEBUG: Splitting query string by '&'\")\n    param_pairs = query_string.split('&')\n    print(f\"DEBUG: Parameter pairs: {param_pairs}\")\n    \n    for i, param in enumerate(param_pairs):\n        print(f\"DEBUG: Processing parameter pair {i+1}/{len(param_pairs)}: {param!r}\")\n        \n        if '=' in param:\n            print(f\"DEBUG: Splitting parameter at '='\")\n            key_value = param.split('=', 1)\n            assert len(key_value) == 2, f\"Unexpected split result for parameter: {param!r}\"\n            \n            key, value = key_value\n            print(f\"DEBUG: Extracted key: {key!r}, value: {value!r}\")\n            \n            # キーが空でないことを確認\n            if not key:\n                print(\"DEBUG: Empty key found, skipping\")\n                continue\n                \n            params[key] = value\n        else:\n            print(f\"DEBUG: No '=' found in parameter, skipping: {param!r}\")\n    \n    print(f\"DEBUG: Parsed parameters: {params}\")\n    return params", "test_cases": {"success": [{"input": ["'https://example.com?name=John&age=30'"], "expected_output": "{'name': 'John', 'age': '30'}"}, {"input": ["'https://example.com'"], "expected_output": "{}"}, {"input": ["'https://example.com?'"], "expected_output": "{}"}], "failure": [{"input": [123], "expected_exception": "AssertionError", "expected_message_part": "URL must be a string, got int"}, {"input": ["'https://example.com?invalid-param'"], "expected_output": "{}"}, {"input": ["'https://example.com?=value'"], "expected_output": "{}"}]}}
{"title": "配列の二分探索関数", "description": "ソート済み配列に対して二分探索を行う関数です。入力値の検証、検索アルゴリズムの各ステップでのインデックスと値の追跡、境界条件のチェックなどをアサーションとデバッグプリントで強化しています。再帰や反復を含むアルゴリズムでは、各ステップの状態変化を追跡するデバッグプリントが特に効果的です。", "keywords": ["algorithm", "binary search", "sorted array", "recursion", "loop", "assertion"], "code_before": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return -1", "code_after": "def binary_search(arr, target):\n    print(f\"DEBUG: Starting binary search for {target} in array of length {len(arr)}\")\n    \n    # 入力が配列/リストかチェック\n    assert isinstance(arr, (list, tuple)), f\"Array must be a list or tuple, got {type(arr).__name__}\"\n    \n    # 配列が空でないことをチェック\n    if not arr:\n        print(\"DEBUG: Array is empty, returning -1\")\n        return -1\n    \n    # 配列がソートされていることをチェック\n    assert all(arr[i] <= arr[i+1] for i in range(len(arr)-1)), \"Array must be sorted in ascending order\"\n    \n    left, right = 0, len(arr) - 1\n    print(f\"DEBUG: Initial search range: left={left}, right={right}\")\n    \n    iteration = 0\n    while left <= right:\n        iteration += 1\n        print(f\"\\nDEBUG: Iteration {iteration}: left={left}, right={right}\")\n        \n        # インデックスの境界チェック\n        assert 0 <= left < len(arr), f\"Left index out of bounds: {left}\"\n        assert 0 <= right < len(arr), f\"Right index out of bounds: {right}\"\n        \n        # mid = (left + right) // 2  # オーバーフローの可能性あり\n        mid = left + (right - left) // 2  # オーバーフロー防止\n        print(f\"DEBUG: Calculated mid index: {mid}, value at mid: {arr[mid]}\")\n        \n        if arr[mid] == target:\n            print(f\"DEBUG: Target {target} found at index {mid}\")\n            return mid\n        elif arr[mid] < target:\n            print(f\"DEBUG: Value at mid ({arr[mid]}) < target ({target}), searching right half\")\n            left = mid + 1\n            print(f\"DEBUG: Updated left index: {left}\")\n        else:\n            print(f\"DEBUG: Value at mid ({arr[mid]}) > target ({target}), searching left half\")\n            right = mid - 1\n            print(f\"DEBUG: Updated right index: {right}\")\n            \n    print(f\"DEBUG: Target {target} not found in array, returning -1\")\n    return -1", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "7"], "expected_output": "6"}, {"input": ["[1, 3, 5, 7, 9]", "5"], "expected_output": "2"}, {"input": ["[1, 3, 5, 7, 9]", "4"], "expected_output": "-1"}, {"input": ["[]", "5"], "expected_output": "-1"}], "failure": [{"input": ["'not a list'", "5"], "expected_exception": "AssertionError", "expected_message_part": "Array must be a list or tuple, got str"}, {"input": ["[10, 9, 8, 7, 6]", "8"], "expected_exception": "AssertionError", "expected_message_part": "Array must be sorted in ascending order"}]}}
