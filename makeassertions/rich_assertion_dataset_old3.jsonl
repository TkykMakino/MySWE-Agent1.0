{"description": "数値データのリスト操作に対するアサーションとデバッグプリントの例です。リスト内の数値を処理する際に、入力リストの有効性検証、計算過程の追跡、関数終了時の状態確認が重要です。特に、空のリストや非数値要素が含まれるケースを検出する際に効果的です。", "keywords": ["list", "sum", "average", "numeric", "validation"], "code_before": "def calculate_average(numbers):\n    total = sum(numbers)\n    return total / len(numbers)", "code_after": "def calculate_average(numbers):\n    print(f\"[DEBUG] calculate_average() called with: {numbers}\")\n    \n    # Input validation assertions\n    assert isinstance(numbers, list), f\"Expected list but got {type(numbers)}\"\n    assert len(numbers) > 0, \"Cannot calculate average of empty list\"\n    assert all(isinstance(x, (int, float)) for x in numbers), \"All elements must be numbers\"\n    \n    # Calculate sum with debug info\n    total = sum(numbers)\n    print(f\"[DEBUG] Sum calculated: {total}\")\n    \n    # Calculate average\n    result = total / len(numbers)\n    print(f\"[DEBUG] Average calculated: {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["[1, 2, 3, 4, 5]"], "expected_output": "3.0"}, {"input": ["[10.5, 20.5, 30]"], "expected_output": "20.333333333333332"}], "failure": [{"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "Expected list but got"}, {"input": ["[]"], "expected_exception": "AssertionError", "expected_message_part": "Cannot calculate average of empty list"}, {"input": ["[1, 2, '3', 4]"], "expected_exception": "AssertionError", "expected_message_part": "All elements must be numbers"}]}}
{"description": "文字列処理関数に対するアサーションとデバッグプリントの例です。文字列の分割・結合操作において、入力パラメータの型と長さの検証、変換中のデータの状態確認、処理結果のフォーマットを監視する場合に有効です。特に文字列処理のエッジケース（空文字、特殊文字など）を検出するのに役立ちます。", "keywords": ["string", "split", "join", "capitalize", "validation"], "code_before": "def format_name(full_name, separator=' '):\n    parts = full_name.split(separator)\n    formatted_parts = [part.capitalize() for part in parts]\n    return ' '.join(formatted_parts)", "code_after": "def format_name(full_name, separator=' '):\n    print(f\"[DEBUG] format_name() started with full_name='{full_name}', separator='{separator}'\")\n    \n    # Input validation\n    assert isinstance(full_name, str), f\"full_name must be a string, got {type(full_name)}\"\n    assert isinstance(separator, str), f\"separator must be a string, got {type(separator)}\"\n    assert len(full_name) > 0, \"full_name cannot be empty\"\n    \n    # Split the name with debug info\n    parts = full_name.split(separator)\n    print(f\"[DEBUG] Name split into parts: {parts}\")\n    \n    # Capitalize each part with debug info\n    formatted_parts = [part.capitalize() for part in parts]\n    print(f\"[DEBUG] Capitalized parts: {formatted_parts}\")\n    \n    # Join the parts\n    result = ' '.join(formatted_parts)\n    print(f\"[DEBUG] Final formatted name: '{result}'\")\n    \n    return result", "test_cases": {"success": [{"input": ["'john doe'", "' '"], "expected_output": "'John Doe'"}, {"input": ["'smith-jones'", "'-'"], "expected_output": "'Smith Jones'"}, {"input": ["'van.der.waals'", "'.'"], "expected_output": "'Van Der Waals'"}], "failure": [{"input": ["123", "' '"], "expected_exception": "AssertionError", "expected_message_part": "full_name must be a string"}, {"input": ["'john'", "123"], "expected_exception": "AssertionError", "expected_message_part": "separator must be a string"}, {"input": ["''", "' '"], "expected_exception": "AssertionError", "expected_message_part": "full_name cannot be empty"}]}}
{"description": "辞書処理操作のためのアサーションとデバッグプリントの例です。辞書からのデータ抽出と変換において、入力辞書の構造検証、キー存在の確認、中間処理結果の追跡が必要な場合に効果的です。特に複雑な辞書構造を扱う際や、必須キーが存在しない可能性がある場合の安全な処理に有用です。", "keywords": ["dict", "get", "keys", "validation", "nested"], "code_before": "def extract_user_info(user_data):\n    name = user_data['name']\n    age = user_data.get('age', 'Unknown')\n    email = user_data.get('contact', {}).get('email', 'No email')\n    return {'name': name, 'age': age, 'email': email}", "code_after": "def extract_user_info(user_data):\n    print(f\"[DEBUG] extract_user_info() called with: {user_data}\")\n    \n    # Input validation\n    assert isinstance(user_data, dict), f\"user_data must be a dictionary, got {type(user_data)}\"\n    assert 'name' in user_data, \"Missing required key 'name' in user_data\"\n    assert isinstance(user_data['name'], str), f\"'name' must be a string, got {type(user_data['name'])}\"\n    \n    # Extract name with debug info\n    name = user_data['name']\n    print(f\"[DEBUG] Extracted name: '{name}'\")\n    \n    # Extract age with debug info\n    age = user_data.get('age', 'Unknown')\n    print(f\"[DEBUG] Extracted age: {age}\")\n    \n    # Validate contact field if present\n    if 'contact' in user_data:\n        assert isinstance(user_data['contact'], dict), f\"'contact' must be a dictionary, got {type(user_data['contact'])}\"\n        print(f\"[DEBUG] Contact information found: {user_data['contact']}\")\n    else:\n        print(\"[DEBUG] No contact information found\")\n    \n    # Extract email with debug info\n    email = user_data.get('contact', {}).get('email', 'No email')\n    print(f\"[DEBUG] Extracted email: '{email}'\")\n    \n    # Prepare and return result\n    result = {'name': name, 'age': age, 'email': email}\n    print(f\"[DEBUG] Returning user info: {result}\")\n    \n    return result", "test_cases": {"success": [{"input": ["{'name': 'John', 'age': 30, 'contact': {'email': 'john@example.com', 'phone': '123-456-7890'}}"], "expected_output": "{'name': 'John', 'age': 30, 'email': 'john@example.com'}"}, {"input": ["{'name': 'Alice', 'contact': {}}"], "expected_output": "{'name': 'Alice', 'age': 'Unknown', 'email': 'No email'}"}, {"input": ["{'name': 'Bob'}"], "expected_output": "{'name': 'Bob', 'age': 'Unknown', 'email': 'No email'}"}], "failure": [{"input": ["[1, 2, 3]"], "expected_exception": "AssertionError", "expected_message_part": "user_data must be a dictionary"}, {"input": ["{}"], "expected_exception": "AssertionError", "expected_message_part": "Missing required key 'name'"}, {"input": ["{'name': 123}"], "expected_exception": "AssertionError", "expected_message_part": "'name' must be a string"}, {"input": ["{'name': 'Charlie', 'contact': 'invalid'}"], "expected_exception": "AssertionError", "expected_message_part": "'contact' must be a dictionary"}]}}
{"description": "ファイルパス操作関数に対するアサーションとデバッグプリントの例です。ファイルパスの構築と検証において、入力パラメータの形式確認、パス連結の各段階の監視、ファイル拡張子の適切な処理の追跡に有効です。特にファイルシステム操作前の安全性確保や、OS間の互換性問題検出に役立ちます。", "keywords": ["path", "file", "extension", "join", "validation"], "code_before": "def build_file_path(directory, filename, extension=None):\n    if extension and not filename.endswith('.' + extension):\n        filename = filename + '.' + extension\n    return directory + '/' + filename", "code_after": "def build_file_path(directory, filename, extension=None):\n    print(f\"[DEBUG] build_file_path() called with directory='{directory}', filename='{filename}', extension='{extension}'\")\n    \n    # Input validation\n    assert isinstance(directory, str), f\"directory must be a string, got {type(directory)}\"\n    assert isinstance(filename, str), f\"filename must be a string, got {type(filename)}\"\n    assert len(directory) > 0, \"directory cannot be empty\"\n    assert len(filename) > 0, \"filename cannot be empty\"\n    assert '/' not in filename, \"filename cannot contain path separators\"\n    \n    if extension is not None:\n        assert isinstance(extension, str), f\"extension must be a string or None, got {type(extension)}\"\n        assert not extension.startswith('.'), \"extension should not start with a dot\"\n        print(f\"[DEBUG] Validating extension: '{extension}'\")\n    \n    # Process filename with extension\n    original_filename = filename\n    if extension and not filename.endswith('.' + extension):\n        filename = filename + '.' + extension\n        print(f\"[DEBUG] Added extension to filename: '{original_filename}' -> '{filename}'\")\n    else:\n        print(f\"[DEBUG] Using filename as is: '{filename}'\")\n    \n    # Ensure directory doesn't end with slash\n    if directory.endswith('/'):\n        directory = directory[:-1]\n        print(f\"[DEBUG] Removed trailing slash from directory: '{directory}'\")\n    \n    # Build and return path\n    result = directory + '/' + filename\n    print(f\"[DEBUG] Built file path: '{result}'\")\n    \n    return result", "test_cases": {"success": [{"input": ["'/home/user/documents'", "'report'", "'txt'"], "expected_output": "'/home/user/documents/report.txt'"}, {"input": ["'/var/log'", "'app.log'", "None"], "expected_output": "'/var/log/app.log'"}, {"input": ["'/tmp/'", "'data'", "'csv'"], "expected_output": "'/tmp/data.csv'"}, {"input": ["'/usr/share'", "'config.json'", "'json'"], "expected_output": "'/usr/share/config.json'"}], "failure": [{"input": ["123", "'file'", "'txt'"], "expected_exception": "AssertionError", "expected_message_part": "directory must be a string"}, {"input": ["'/tmp'", "123", "'txt'"], "expected_exception": "AssertionError", "expected_message_part": "filename must be a string"}, {"input": ["''", "'file'", "'txt'"], "expected_exception": "AssertionError", "expected_message_part": "directory cannot be empty"}, {"input": ["'/tmp'", "''", "'txt'"], "expected_exception": "AssertionError", "expected_message_part": "filename cannot be empty"}, {"input": ["'/tmp'", "'file/name'", "'txt'"], "expected_exception": "AssertionError", "expected_message_part": "filename cannot contain path separators"}, {"input": ["'/tmp'", "'file'", "123"], "expected_exception": "AssertionError", "expected_message_part": "extension must be a string or None"}, {"input": ["'/tmp'", "'file'", "'.txt'"], "expected_exception": "AssertionError", "expected_message_part": "extension should not start with a dot"}]}}
